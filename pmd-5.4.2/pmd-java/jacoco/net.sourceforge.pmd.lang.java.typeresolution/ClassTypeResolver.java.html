<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassTypeResolver.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Java</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.java.typeresolution</a> &gt; <span class="el_source">ClassTypeResolver.java</span></div><h1>ClassTypeResolver.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
package net.sourceforge.pmd.lang.java.typeresolution;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import net.sourceforge.pmd.lang.ast.AbstractNode;
import net.sourceforge.pmd.lang.ast.Node;
import net.sourceforge.pmd.lang.java.ast.ASTAdditiveExpression;
import net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;
import net.sourceforge.pmd.lang.java.ast.ASTAndExpression;
import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimsAndInits;
import net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;
import net.sourceforge.pmd.lang.java.ast.ASTCastExpression;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;
import net.sourceforge.pmd.lang.java.ast.ASTConditionalAndExpression;
import net.sourceforge.pmd.lang.java.ast.ASTConditionalExpression;
import net.sourceforge.pmd.lang.java.ast.ASTConditionalOrExpression;
import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;
import net.sourceforge.pmd.lang.java.ast.ASTExclusiveOrExpression;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTInclusiveOrExpression;
import net.sourceforge.pmd.lang.java.ast.ASTInstanceOfExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;
import net.sourceforge.pmd.lang.java.ast.ASTMultiplicativeExpression;
import net.sourceforge.pmd.lang.java.ast.ASTName;
import net.sourceforge.pmd.lang.java.ast.ASTNormalAnnotation;
import net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;
import net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTPostfixExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPreDecrementExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPreIncrementExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;
import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;
import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;
import net.sourceforge.pmd.lang.java.ast.ASTReferenceType;
import net.sourceforge.pmd.lang.java.ast.ASTRelationalExpression;
import net.sourceforge.pmd.lang.java.ast.ASTShiftExpression;
import net.sourceforge.pmd.lang.java.ast.ASTSingleMemberAnnotation;
import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression;
import net.sourceforge.pmd.lang.java.ast.ASTUnaryExpressionNotPlusMinus;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;
import net.sourceforge.pmd.lang.java.ast.TypeNode;

//
// Helpful reading:
// http://www.janeg.ca/scjp/oper/promotions.html
// http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html
//

public class ClassTypeResolver extends JavaParserVisitorAdapter {

<span class="fc" id="L74">	private static final Logger LOG = Logger.getLogger(ClassTypeResolver.class.getName());</span>

	private static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVE_TYPES;
	private static final Map&lt;String, String&gt; JAVA_LANG;

	static {
		// Note: Assumption here that primitives come from same parent ClassLoader regardless of what ClassLoader we are passed
<span class="fc" id="L81">		Map&lt;String, Class&lt;?&gt;&gt; thePrimitiveTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L82">		thePrimitiveTypes.put(&quot;void&quot;, Void.TYPE);</span>
<span class="fc" id="L83">		thePrimitiveTypes.put(&quot;boolean&quot;, Boolean.TYPE);</span>
<span class="fc" id="L84">		thePrimitiveTypes.put(&quot;byte&quot;, Byte.TYPE);</span>
<span class="fc" id="L85">		thePrimitiveTypes.put(&quot;char&quot;, Character.TYPE);</span>
<span class="fc" id="L86">		thePrimitiveTypes.put(&quot;short&quot;, Short.TYPE);</span>
<span class="fc" id="L87">		thePrimitiveTypes.put(&quot;int&quot;, Integer.TYPE);</span>
<span class="fc" id="L88">		thePrimitiveTypes.put(&quot;long&quot;, Long.TYPE);</span>
<span class="fc" id="L89">		thePrimitiveTypes.put(&quot;float&quot;, Float.TYPE);</span>
<span class="fc" id="L90">		thePrimitiveTypes.put(&quot;double&quot;, Double.TYPE);</span>
<span class="fc" id="L91">		PRIMITIVE_TYPES = Collections.unmodifiableMap(thePrimitiveTypes);</span>

<span class="fc" id="L93">		Map&lt;String, String&gt; theJavaLang = new HashMap&lt;&gt;();</span>
<span class="fc" id="L94">		theJavaLang.put(&quot;Boolean&quot;, &quot;java.lang.Boolean&quot;);</span>
<span class="fc" id="L95">		theJavaLang.put(&quot;Byte&quot;, &quot;java.lang.Byte&quot;);</span>
<span class="fc" id="L96">		theJavaLang.put(&quot;Character&quot;, &quot;java.lang.Character&quot;);</span>
<span class="fc" id="L97">		theJavaLang.put(&quot;CharSequence&quot;, &quot;java.lang.CharSequence&quot;);</span>
<span class="fc" id="L98">		theJavaLang.put(&quot;Class&quot;, &quot;java.lang.Class&quot;);</span>
<span class="fc" id="L99">		theJavaLang.put(&quot;ClassLoader&quot;, &quot;java.lang.ClassLoader&quot;);</span>
<span class="fc" id="L100">		theJavaLang.put(&quot;Cloneable&quot;, &quot;java.lang.Cloneable&quot;);</span>
<span class="fc" id="L101">		theJavaLang.put(&quot;Comparable&quot;, &quot;java.lang.Comparable&quot;);</span>
<span class="fc" id="L102">		theJavaLang.put(&quot;Compiler&quot;, &quot;java.lang.Compiler&quot;);</span>
<span class="fc" id="L103">		theJavaLang.put(&quot;Double&quot;, &quot;java.lang.Double&quot;);</span>
<span class="fc" id="L104">		theJavaLang.put(&quot;Float&quot;, &quot;java.lang.Float&quot;);</span>
<span class="fc" id="L105">		theJavaLang.put(&quot;InheritableThreadLocal&quot;, &quot;java.lang.InheritableThreadLocal&quot;);</span>
<span class="fc" id="L106">		theJavaLang.put(&quot;Integer&quot;, &quot;java.lang.Integer&quot;);</span>
<span class="fc" id="L107">		theJavaLang.put(&quot;Long&quot;, &quot;java.lang.Long&quot;);</span>
<span class="fc" id="L108">		theJavaLang.put(&quot;Math&quot;, &quot;java.lang.Math&quot;);</span>
<span class="fc" id="L109">		theJavaLang.put(&quot;Number&quot;, &quot;java.lang.Number&quot;);</span>
<span class="fc" id="L110">		theJavaLang.put(&quot;Object&quot;, &quot;java.lang.Object&quot;);</span>
<span class="fc" id="L111">		theJavaLang.put(&quot;Package&quot;, &quot;java.lang.Package&quot;);</span>
<span class="fc" id="L112">		theJavaLang.put(&quot;Process&quot;, &quot;java.lang.Process&quot;);</span>
<span class="fc" id="L113">		theJavaLang.put(&quot;Runnable&quot;, &quot;java.lang.Runnable&quot;);</span>
<span class="fc" id="L114">		theJavaLang.put(&quot;Runtime&quot;, &quot;java.lang.Runtime&quot;);</span>
<span class="fc" id="L115">		theJavaLang.put(&quot;RuntimePermission&quot;, &quot;java.lang.RuntimePermission&quot;);</span>
<span class="fc" id="L116">		theJavaLang.put(&quot;SecurityManager&quot;, &quot;java.lang.SecurityManager&quot;);</span>
<span class="fc" id="L117">		theJavaLang.put(&quot;Short&quot;, &quot;java.lang.Short&quot;);</span>
<span class="fc" id="L118">		theJavaLang.put(&quot;StackTraceElement&quot;, &quot;java.lang.StackTraceElement&quot;);</span>
<span class="fc" id="L119">		theJavaLang.put(&quot;StrictMath&quot;, &quot;java.lang.StrictMath&quot;);</span>
<span class="fc" id="L120">		theJavaLang.put(&quot;String&quot;, &quot;java.lang.String&quot;);</span>
<span class="fc" id="L121">		theJavaLang.put(&quot;StringBuffer&quot;, &quot;java.lang.StringBuffer&quot;);</span>
<span class="fc" id="L122">		theJavaLang.put(&quot;System&quot;, &quot;java.lang.System&quot;);</span>
<span class="fc" id="L123">		theJavaLang.put(&quot;Thread&quot;, &quot;java.lang.Thread&quot;);</span>
<span class="fc" id="L124">		theJavaLang.put(&quot;ThreadGroup&quot;, &quot;java.lang.ThreadGroup&quot;);</span>
<span class="fc" id="L125">		theJavaLang.put(&quot;ThreadLocal&quot;, &quot;java.lang.ThreadLocal&quot;);</span>
<span class="fc" id="L126">		theJavaLang.put(&quot;Throwable&quot;, &quot;java.lang.Throwable&quot;);</span>
<span class="fc" id="L127">		theJavaLang.put(&quot;Void&quot;, &quot;java.lang.Void&quot;);</span>
<span class="fc" id="L128">		JAVA_LANG = Collections.unmodifiableMap(theJavaLang);</span>
<span class="fc" id="L129">	}</span>

	private final PMDASMClassLoader pmdClassLoader;
	private Map&lt;String, String&gt; importedClasses;
	private List&lt;String&gt; importedOnDemand;
<span class="fc" id="L134">	private int anonymousClassCounter = 0;</span>
	
	public ClassTypeResolver() {
<span class="fc" id="L137">		this(ClassTypeResolver.class.getClassLoader());</span>
<span class="fc" id="L138">	}</span>

<span class="fc" id="L140">	public ClassTypeResolver(ClassLoader classLoader) {</span>
<span class="fc" id="L141">		pmdClassLoader = PMDASMClassLoader.getInstance(classLoader);</span>
<span class="fc" id="L142">	}</span>

	// FUTURE ASTCompilationUnit should not be a TypeNode.  Clean this up accordingly.
	@Override
	public Object visit(ASTCompilationUnit node, Object data) {
<span class="fc" id="L147">		String className = null;</span>
		try {
<span class="fc" id="L149">			importedOnDemand = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L150">			importedClasses = new HashMap&lt;&gt;();</span>
<span class="fc" id="L151">			className = getClassName(node);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">			if (className != null) {</span>
<span class="fc" id="L153">				populateClassName(node, className);</span>
			}
<span class="fc" id="L155">		} catch (ClassNotFoundException e) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			if (LOG.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L157">				LOG.log(Level.FINE, &quot;Could not find class &quot; + className + &quot;, due to: &quot; + e);</span>
			}
<span class="nc" id="L159">		} catch (NoClassDefFoundError e) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">			if (LOG.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L161"> 				LOG.log(Level.FINE, &quot;Could not find class &quot; + className + &quot;, due to: &quot; + e);</span>
 			}
<span class="nc" id="L163">		} catch (LinkageError e) {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">			if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L165">				LOG.log(Level.WARNING, &quot;Could not find class &quot; + className + &quot;, due to: &quot; + e);</span>
			}
		} finally {
<span class="pc" id="L168">			populateImports(node);</span>
<span class="pc" id="L169">		}</span>
<span class="fc" id="L170">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTImportDeclaration node, Object data) {
<span class="fc" id="L175">		ASTName importedType = (ASTName)node.jjtGetChild(0);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">		if (importedType.getType() != null) {</span>
<span class="nc" id="L177">			node.setType(importedType.getType());</span>
		} else {
<span class="fc" id="L179">			populateType(node, importedType.getImage());</span>
		}

<span class="fc bfc" id="L182" title="All 2 branches covered.">		if (node.getType() != null) {</span>
<span class="fc" id="L183">			node.setPackage(node.getType().getPackage());</span>
		}
<span class="fc" id="L185">		return data;</span>
	}

	@Override
	public Object visit(ASTTypeDeclaration node, Object data) {
<span class="fc" id="L190">		super.visit(node, data);</span>
<span class="fc" id="L191">		rollupTypeUnary(node);</span>
<span class="fc" id="L192">		return data;</span>
	}

	@Override
	public Object visit(ASTClassOrInterfaceType node, Object data) {
<span class="fc" id="L197">		String typeName = node.getImage();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">		if (node.jjtGetParent().hasDescendantOfType(ASTClassOrInterfaceBody.class)) {</span>
<span class="fc" id="L199">			anonymousClassCounter++;</span>
<span class="fc" id="L200">		    AbstractNode parent = node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">		    if (parent == null) {</span>
<span class="fc" id="L202">		        parent = node.getFirstParentOfType(ASTEnumDeclaration.class);</span>
		    }
<span class="fc" id="L204">            typeName = parent.getImage() + &quot;$&quot; + anonymousClassCounter;</span>
		}
<span class="fc" id="L206">		populateType(node, typeName);</span>
<span class="fc" id="L207">		return data;</span>
	}

	@Override
	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
<span class="fc" id="L212">		populateType(node, node.getImage());</span>
<span class="fc" id="L213">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTEnumDeclaration node, Object data) {
<span class="fc" id="L218">		populateType(node, node.getImage());</span>
<span class="fc" id="L219">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTAnnotationTypeDeclaration node, Object data) {
<span class="fc" id="L224">		populateType(node, node.getImage());</span>
<span class="fc" id="L225">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTName node, Object data) {
		/*
		 * Only doing this for nodes where getNameDeclaration is null this means
		 * it's not a named node, i.e. Static reference or Annotation Doing this
		 * for memory - TODO: Investigate if there is a valid memory concern or
		 * not
		 */
<span class="fc bfc" id="L236" title="All 2 branches covered.">		if (node.getNameDeclaration() == null) {</span>
			// Skip these scenarios as there is no type to populate in these cases:
			// 1) Parent is a PackageDeclaration, which is not a type
			// 2) Parent is a ImportDeclaration, this is handled elsewhere.
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">			if (!(node.jjtGetParent() instanceof ASTPackageDeclaration || node.jjtGetParent() instanceof ASTImportDeclaration)) {</span>
<span class="fc" id="L241">				String name = node.getImage();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">				if (name.indexOf('.') != -1) {</span>
<span class="fc" id="L243">					name = name.substring(0, name.indexOf('.'));</span>
				}
<span class="fc" id="L245">				populateType(node, name);</span>
<span class="fc" id="L246">			}</span>
		} else {
			// Carry over the type from the declaration
<span class="fc bfc" id="L249" title="All 2 branches covered.">			if (node.getNameDeclaration().getNode() instanceof TypeNode) {</span>
<span class="fc" id="L250">				node.setType(((TypeNode)node.getNameDeclaration().getNode()).getType());</span>
			}
		}
<span class="fc" id="L253">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTFieldDeclaration node, Object data) {
<span class="fc" id="L258">		super.visit(node, data);</span>
<span class="fc" id="L259">		rollupTypeUnary(node);</span>
<span class="fc" id="L260">		return data;</span>
	}

	@Override
	public Object visit(ASTVariableDeclarator node, Object data) {
<span class="fc" id="L265">		super.visit(node, data);</span>
<span class="fc" id="L266">		rollupTypeUnary(node);</span>
<span class="fc" id="L267">		return data;</span>
	}

	@Override
	public Object visit(ASTVariableDeclaratorId node, Object data) {
<span class="pc bpc" id="L272" title="2 of 4 branches missed.">		if (node == null || node.getNameDeclaration() == null) {</span>
<span class="nc" id="L273">			return super.visit(node, data);</span>
		}
<span class="fc" id="L275">		String name = node.getNameDeclaration().getTypeImage();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (name != null) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">    		if (name.indexOf('.') != -1) {</span>
<span class="fc" id="L278">    			name = name.substring(0, name.indexOf('.'));</span>
    		}
<span class="fc" id="L280">    		populateType(node, name);</span>
		}
<span class="fc" id="L282">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTType node, Object data) {
<span class="fc" id="L287">		super.visit(node, data);</span>
<span class="fc" id="L288">		rollupTypeUnary(node);</span>
<span class="fc" id="L289">		return data;</span>
	}

	@Override
	public Object visit(ASTReferenceType node, Object data) {
<span class="fc" id="L294">		super.visit(node, data);</span>
<span class="fc" id="L295">		rollupTypeUnary(node);</span>
<span class="fc" id="L296">		return data;</span>
	}

	@Override
	public Object visit(ASTPrimitiveType node, Object data) {
<span class="fc" id="L301">		populateType(node, node.getImage());</span>
<span class="fc" id="L302">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTExpression node, Object data) {
<span class="fc" id="L307">		super.visit(node, data);</span>
<span class="fc" id="L308">		rollupTypeUnary(node);</span>
<span class="fc" id="L309">		return data;</span>
	}

	@Override
	public Object visit(ASTConditionalExpression node, Object data) {
<span class="fc" id="L314">		super.visit(node, data);</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">		if (node.isTernary()) {</span>
			// TODO Rules for Ternary are complex
		} else {
<span class="nc" id="L318">			rollupTypeUnary(node);</span>
		}
<span class="fc" id="L320">		return data;</span>
	}

	@Override
	public Object visit(ASTConditionalOrExpression node, Object data) {
<span class="fc" id="L325">		populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L326">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTConditionalAndExpression node, Object data) {
<span class="fc" id="L331">		populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L332">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTInclusiveOrExpression node, Object data) {
<span class="fc" id="L337">		super.visit(node, data);</span>
<span class="fc" id="L338">		rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L339">		return data;</span>
	}

	@Override
	public Object visit(ASTExclusiveOrExpression node, Object data) {
<span class="fc" id="L344">		super.visit(node, data);</span>
<span class="fc" id="L345">		rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L346">		return data;</span>
	}

	@Override
	public Object visit(ASTAndExpression node, Object data) {
<span class="fc" id="L351">		super.visit(node, data);</span>
<span class="fc" id="L352">		rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L353">		return data;</span>
	}

	@Override
	public Object visit(ASTEqualityExpression node, Object data) {
<span class="fc" id="L358">		populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L359">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTInstanceOfExpression node, Object data) {
<span class="fc" id="L364">		populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L365">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTRelationalExpression node, Object data) {
<span class="fc" id="L370">		populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L371">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTShiftExpression node, Object data) {
<span class="fc" id="L376">		super.visit(node, data);</span>
		// Unary promotion on LHS is type of a shift operation
<span class="fc" id="L378">		rollupTypeUnaryNumericPromotion(node);</span>
<span class="fc" id="L379">		return data;</span>
	}

	@Override
	public Object visit(ASTAdditiveExpression node, Object data) {
<span class="fc" id="L384">		super.visit(node, data);</span>
<span class="fc" id="L385">		rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L386">		return data;</span>
	}

	@Override
	public Object visit(ASTMultiplicativeExpression node, Object data) {
<span class="fc" id="L391">		super.visit(node, data);</span>
<span class="fc" id="L392">		rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L393">		return data;</span>
	}

	@Override
	public Object visit(ASTUnaryExpression node, Object data) {
<span class="fc" id="L398">		super.visit(node, data);</span>
<span class="fc" id="L399">		rollupTypeUnaryNumericPromotion(node);</span>
<span class="fc" id="L400">		return data;</span>
	}

	@Override
	public Object visit(ASTPreIncrementExpression node, Object data) {
<span class="fc" id="L405">		super.visit(node, data);</span>
<span class="fc" id="L406">		rollupTypeUnary(node);</span>
<span class="fc" id="L407">		return data;</span>
	}

	@Override
	public Object visit(ASTPreDecrementExpression node, Object data) {
<span class="fc" id="L412">		super.visit(node, data);</span>
<span class="fc" id="L413">		rollupTypeUnary(node);</span>
<span class="fc" id="L414">		return data;</span>
	}

	@Override
	public Object visit(ASTUnaryExpressionNotPlusMinus node, Object data) {
<span class="fc" id="L419">		super.visit(node, data);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">		if (&quot;!&quot;.equals(node.getImage())) {</span>
<span class="fc" id="L421">			populateType(node, &quot;boolean&quot;);</span>
		} else {
<span class="fc" id="L423">			rollupTypeUnary(node);</span>
		}
<span class="fc" id="L425">		return data;</span>
	}

	@Override
	public Object visit(ASTPostfixExpression node, Object data) {
<span class="fc" id="L430">		super.visit(node, data);</span>
<span class="fc" id="L431">		rollupTypeUnary(node);</span>
<span class="fc" id="L432">		return data;</span>
	}

	@Override
	public Object visit(ASTCastExpression node, Object data) {
<span class="fc" id="L437">		super.visit(node, data);</span>
<span class="fc" id="L438">		rollupTypeUnary(node);</span>
<span class="fc" id="L439">		return data;</span>
	}

	@Override
	public Object visit(ASTPrimaryExpression node, Object data) {
<span class="fc" id="L444">		super.visit(node, data);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">		if (node.jjtGetNumChildren() == 1) {</span>
<span class="fc" id="L446">			rollupTypeUnary(node);</span>
		} else {
			// TODO OMG, this is complicated.  PrimaryExpression, PrimaryPrefix and PrimarySuffix are all related.
		}
<span class="fc" id="L450">		return data;</span>
	}

	@Override
	public Object visit(ASTPrimaryPrefix node, Object data) {
<span class="fc" id="L455">		super.visit(node, data);</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">		if (node.getImage() == null) {</span>
<span class="fc" id="L457">			rollupTypeUnary(node);</span>
		} else {
			// TODO OMG, this is complicated.  PrimaryExpression, PrimaryPrefix and PrimarySuffix are all related.
		}
<span class="fc" id="L461">		return data;</span>
	}

	@Override
	public Object visit(ASTPrimarySuffix node, Object data) {
<span class="fc" id="L466">		super.visit(node, data);</span>
		// TODO OMG, this is complicated.  PrimaryExpression, PrimaryPrefix and PrimarySuffix are all related.
<span class="fc" id="L468">		return data;</span>
	}

	@Override
	public Object visit(ASTNullLiteral node, Object data) {
		// No explicit type
<span class="fc" id="L474">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTBooleanLiteral node, Object data) {
<span class="fc" id="L479">		populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L480">		return super.visit(node, data);</span>
	}

	@Override
	public Object visit(ASTLiteral node, Object data) {
<span class="fc" id="L485">		super.visit(node, data);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">		if (node.jjtGetNumChildren() != 0) {</span>
<span class="fc" id="L487">			rollupTypeUnary(node);</span>
		} else {
<span class="fc bfc" id="L489" title="All 2 branches covered.">			if (node.isIntLiteral()) {</span>
<span class="fc" id="L490">			    populateType(node, &quot;int&quot;);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">			} else if (node.isLongLiteral()) {</span>
<span class="fc" id="L492">				populateType(node, &quot;long&quot;);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">			} else if (node.isFloatLiteral()) {</span>
<span class="fc" id="L494">			    populateType(node, &quot;float&quot;);</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">			} else if (node.isDoubleLiteral()) {</span>
<span class="fc" id="L496">			    populateType(node, &quot;double&quot;);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">			} else if (node.isCharLiteral()) {</span>
<span class="fc" id="L498">				populateType(node, &quot;char&quot;);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">			} else if (node.isStringLiteral()) {</span>
<span class="fc" id="L500">				populateType(node, &quot;java.lang.String&quot;);</span>
			} else {
<span class="nc" id="L502">				throw new IllegalStateException(&quot;PMD error, unknown literal type!&quot;);</span>
			}
		}
<span class="fc" id="L505">		return data;</span>
	}

	@Override
	public Object visit(ASTAllocationExpression node, Object data) {
<span class="fc" id="L510">		super.visit(node, data);</span>

<span class="pc bpc" id="L512" title="2 of 8 branches missed.">		if (node.jjtGetNumChildren() &gt;= 2 &amp;&amp; node.jjtGetChild(1) instanceof ASTArrayDimsAndInits</span>
				|| node.jjtGetNumChildren() &gt;= 3 &amp;&amp; node.jjtGetChild(2) instanceof ASTArrayDimsAndInits) {
			//
			// Classes for Array types cannot be found directly using reflection.
			// As far as I can tell you have to create an array instance of the necessary
			// dimensionality, and then ask for the type from the instance.  OMFG that's ugly.
			//

			// TODO Need to create utility method to allow array type creation which will use
			// caching to avoid repeated object creation.
			// TODO Modify Parser to tell us array dimensions count.
			// TODO Parser seems to do some work to handle arrays in certain case already.
			// Examine those to figure out what's going on, make sure _all_ array scenarios
			// are ultimately covered.  Appears to use a Dimensionable interface to handle
			// only a part of the APIs (not bump), but is implemented several times, so
			// look at refactoring to eliminate duplication.  Dimensionable is also used
			// on AccessNodes for some scenarios, need to account for that.  Might be
			// missing some TypeNode candidates we can add to the AST and have to deal
			// with here (e.g. FormalParameter)?  Plus some existing usages may be
			// incorrect.
		} else {
<span class="fc" id="L533">			rollupTypeUnary(node);</span>
		}
<span class="fc" id="L535">		return data;</span>
	}

	@Override
	public Object visit(ASTStatementExpression node, Object data) {
<span class="fc" id="L540">		super.visit(node, data);</span>
<span class="fc" id="L541">		rollupTypeUnary(node);</span>
<span class="fc" id="L542">		return data;</span>
	}

    @Override
    public Object visit(ASTNormalAnnotation node, Object data) {
<span class="fc" id="L547">        super.visit(node, data);</span>
<span class="fc" id="L548">        rollupTypeUnary(node);</span>
<span class="fc" id="L549">        return data;</span>
    }

    @Override
    public Object visit(ASTMarkerAnnotation node, Object data) {
<span class="fc" id="L554">        super.visit(node, data);</span>
<span class="fc" id="L555">        rollupTypeUnary(node);</span>
<span class="fc" id="L556">        return data;</span>
    }

    @Override
    public Object visit(ASTSingleMemberAnnotation node, Object data) {
<span class="fc" id="L561">        super.visit(node, data);</span>
<span class="fc" id="L562">        rollupTypeUnary(node);</span>
<span class="fc" id="L563">        return data;</span>
    }

	// Roll up the type based on type of the first child node.
	private void rollupTypeUnary(TypeNode typeNode) {
<span class="fc" id="L568">		Node node = typeNode;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">		if (node.jjtGetNumChildren() &gt;= 1) {</span>
<span class="fc" id="L570">			Node child = node.jjtGetChild(0);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">			if (child instanceof TypeNode) {</span>
<span class="fc" id="L572">				typeNode.setType(((TypeNode)child).getType());</span>
			}
		}
<span class="fc" id="L575">	}</span>

	// Roll up the type based on type of the first child node using Unary Numeric Promotion per JLS 5.6.1
	private void rollupTypeUnaryNumericPromotion(TypeNode typeNode) {
<span class="fc" id="L579">		Node node = typeNode;</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">		if (node.jjtGetNumChildren() &gt;= 1) {</span>
<span class="fc" id="L581">			Node child = node.jjtGetChild(0);</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">			if (child instanceof TypeNode) {</span>
<span class="fc" id="L583">				Class&lt;?&gt; type = ((TypeNode)child).getType();</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">				if (type != null) {</span>
<span class="fc bfc" id="L585" title="All 6 branches covered.">					if (&quot;byte&quot;.equals(type.getName()) || &quot;short&quot;.equals(type.getName())</span>
							|| &quot;char&quot;.equals(type.getName())) {
<span class="fc" id="L587">						populateType(typeNode, &quot;int&quot;);</span>
					} else {
<span class="fc" id="L589">						typeNode.setType(((TypeNode)child).getType());</span>
					}
				}
			}
		}
<span class="fc" id="L594">	}</span>

	// Roll up the type based on type of the first and second child nodes using Binary Numeric Promotion per JLS 5.6.2
	private void rollupTypeBinaryNumericPromotion(TypeNode typeNode) {
<span class="fc" id="L598">		Node node = typeNode;</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">		if (node.jjtGetNumChildren() &gt;= 2) {</span>
<span class="fc" id="L600">			Node child1 = node.jjtGetChild(0);</span>
<span class="fc" id="L601">			Node child2 = node.jjtGetChild(1);</span>
<span class="pc bpc" id="L602" title="2 of 4 branches missed.">			if (child1 instanceof TypeNode &amp;&amp; child2 instanceof TypeNode) {</span>
<span class="fc" id="L603">				Class&lt;?&gt; type1 = ((TypeNode)child1).getType();</span>
<span class="fc" id="L604">				Class&lt;?&gt; type2 = ((TypeNode)child2).getType();</span>
<span class="fc bfc" id="L605" title="All 4 branches covered.">				if (type1 != null &amp;&amp; type2 != null) {</span>
					// Yeah, String is not numeric, but easiest place to handle it, only affects ASTAdditiveExpression
<span class="fc bfc" id="L607" title="All 4 branches covered.">					if (&quot;java.lang.String&quot;.equals(type1.getName()) || &quot;java.lang.String&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L608">						populateType(typeNode, &quot;java.lang.String&quot;);</span>
<span class="pc bpc" id="L609" title="1 of 4 branches missed.">					} else if (&quot;boolean&quot;.equals(type1.getName()) || &quot;boolean&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L610">						populateType(typeNode, &quot;boolean&quot;);</span>
<span class="fc bfc" id="L611" title="All 4 branches covered.">					} else if (&quot;double&quot;.equals(type1.getName()) || &quot;double&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L612">						populateType(typeNode, &quot;double&quot;);</span>
<span class="fc bfc" id="L613" title="All 4 branches covered.">					} else if (&quot;float&quot;.equals(type1.getName()) || &quot;float&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L614">						populateType(typeNode, &quot;float&quot;);</span>
<span class="fc bfc" id="L615" title="All 4 branches covered.">					} else if (&quot;long&quot;.equals(type1.getName()) || &quot;long&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L616">						populateType(typeNode, &quot;long&quot;);</span>
					} else {
<span class="fc" id="L618">						populateType(typeNode, &quot;int&quot;);</span>
					}
<span class="fc bfc" id="L620" title="All 4 branches covered.">				} else if (type1 != null || type2 != null) {</span>
					// If one side is known to be a String, then the result is a String
					// Yeah, String is not numeric, but easiest place to handle it, only affects ASTAdditiveExpression
<span class="fc bfc" id="L623" title="All 8 branches covered.">					if (type1 != null &amp;&amp; &quot;java.lang.String&quot;.equals(type1.getName())</span>
							|| type2 != null &amp;&amp; &quot;java.lang.String&quot;.equals(type2.getName())) {
<span class="fc" id="L625">						populateType(typeNode, &quot;java.lang.String&quot;);</span>
					}
				}
			}
		}
<span class="fc" id="L630">	}</span>

	private void populateType(TypeNode node, String className) {

<span class="fc" id="L634">		String qualifiedName = className;</span>
<span class="fc" id="L635">		Class&lt;?&gt; myType = PRIMITIVE_TYPES.get(className);</span>
<span class="pc bpc" id="L636" title="1 of 4 branches missed.">		if (myType == null &amp;&amp; importedClasses != null) {</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">			if (importedClasses.containsKey(className)) {</span>
<span class="fc" id="L638">				qualifiedName = importedClasses.get(className);</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">			} else if (importedClasses.containsValue(className)) {</span>
<span class="fc" id="L640">				qualifiedName = className;</span>
			}
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">			if (qualifiedName != null) {</span>
				try {
					/*
					 * TODO - the map right now contains just class names. if we
					 * use a map of classname/class then we don't have to hit
					 * the class loader for every type - much faster
					 */
<span class="fc" id="L649">					myType = pmdClassLoader.loadClass(qualifiedName);</span>
<span class="fc" id="L650">				} catch (ClassNotFoundException e) {</span>
<span class="fc" id="L651">					myType = processOnDemand(qualifiedName);</span>
<span class="nc" id="L652">				} catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L653">					myType = processOnDemand(qualifiedName);</span>
<span class="nc" id="L654">				} catch (LinkageError e) {</span>
<span class="nc" id="L655">					myType = processOnDemand(qualifiedName);</span>
<span class="pc" id="L656">				}</span>
			}
		}
<span class="pc bpc" id="L659" title="1 of 6 branches missed.">		if (myType == null &amp;&amp; qualifiedName != null &amp;&amp; qualifiedName.contains(&quot;.&quot;)) {</span>
		    // try if the last part defines a inner class
<span class="fc" id="L661">		    String qualifiedNameInner = qualifiedName.substring(0, qualifiedName.lastIndexOf('.'))</span>
		            + &quot;$&quot; + qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1);
		    try {
<span class="fc" id="L664">		        myType = pmdClassLoader.loadClass(qualifiedNameInner);</span>
<span class="fc" id="L665">		    } catch (Exception e) {</span>
		        // ignored
<span class="fc" id="L667">		    }</span>
		}
<span class="pc bpc" id="L669" title="1 of 6 branches missed.">		if (myType == null &amp;&amp; qualifiedName != null &amp;&amp; !qualifiedName.contains(&quot;.&quot;)) {</span>
		    // try again with java.lang....
		    try {
<span class="fc" id="L672">		        myType = pmdClassLoader.loadClass(&quot;java.lang.&quot; + qualifiedName);</span>
<span class="fc" id="L673">		    } catch (Exception e) {</span>
		        // ignored
<span class="fc" id="L675">		    }</span>
		}
<span class="fc bfc" id="L677" title="All 2 branches covered.">		if (myType != null) {</span>
<span class="fc" id="L678">			node.setType(myType);</span>
		}
<span class="fc" id="L680">	}</span>

	/**
	 * Check whether the supplied class name exists.
	 */
	public boolean classNameExists(String fullyQualifiedClassName) {
		try {
<span class="fc" id="L687">			pmdClassLoader.loadClass(fullyQualifiedClassName);</span>
<span class="fc" id="L688">			return true; //Class found</span>
<span class="fc" id="L689">		} catch (ClassNotFoundException e) {</span>
<span class="fc" id="L690">			return false;</span>
<span class="nc" id="L691">		} catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L692">			return false;</span>
		}
	}

	public Class&lt;?&gt; loadClass(String fullyQualifiedClassName) {
	    try {
<span class="fc" id="L698">            return pmdClassLoader.loadClass(fullyQualifiedClassName);</span>
<span class="nc" id="L699">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L700">            return null;</span>
        }
	}

	private Class&lt;?&gt; processOnDemand(String qualifiedName) {
<span class="fc bfc" id="L705" title="All 2 branches covered.">		for (String entry : importedOnDemand) {</span>
			try {
<span class="fc" id="L707">				return pmdClassLoader.loadClass(entry + &quot;.&quot; + qualifiedName);</span>
<span class="fc" id="L708">			} catch (Throwable e) {</span>
			}
<span class="fc" id="L710">		}</span>
<span class="fc" id="L711">		return null;</span>
	}

	private String getClassName(ASTCompilationUnit node) {
<span class="fc" id="L715">		ASTClassOrInterfaceDeclaration classDecl = node.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">		if (classDecl == null) {</span>
<span class="fc" id="L717">			return null; // Happens if this compilation unit only contains an enum</span>
		}
<span class="fc bfc" id="L719" title="All 2 branches covered.">		if (node.declarationsAreInDefaultPackage()) {</span>
<span class="fc" id="L720">			return classDecl.getImage();</span>
		}
<span class="fc" id="L722">		ASTPackageDeclaration pkgDecl = node.getPackageDeclaration();</span>
<span class="fc" id="L723">		importedOnDemand.add(pkgDecl.getPackageNameImage());</span>
<span class="fc" id="L724">		return pkgDecl.getPackageNameImage() + &quot;.&quot; + classDecl.getImage();</span>
	}

	/**
	 * If the outer class wasn't found then we'll get in here
	 *
	 * @param node
	 */
	private void populateImports(ASTCompilationUnit node) {
<span class="fc" id="L733">		List&lt;ASTImportDeclaration&gt; theImportDeclarations = node.findChildrenOfType(ASTImportDeclaration.class);</span>

<span class="fc" id="L735">		importedClasses.putAll(JAVA_LANG);</span>

		// go through the imports
<span class="fc bfc" id="L738" title="All 2 branches covered.">		for (ASTImportDeclaration anImportDeclaration : theImportDeclarations) {</span>
<span class="fc" id="L739">			String strPackage = anImportDeclaration.getPackageName();</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">			if (anImportDeclaration.isImportOnDemand()) {</span>
<span class="fc" id="L741">				importedOnDemand.add(strPackage);</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">			} else if (!anImportDeclaration.isImportOnDemand()) {</span>
<span class="fc" id="L743">				String strName = anImportDeclaration.getImportedName();</span>
<span class="fc" id="L744">				importedClasses.put(strName, strName);</span>
<span class="fc" id="L745">				importedClasses.put(strName.substring(strPackage.length() + 1), strName);</span>
			}
<span class="fc" id="L747">		}</span>
<span class="fc" id="L748">	}</span>

	private void populateClassName(ASTCompilationUnit node, String className) throws ClassNotFoundException {
<span class="fc" id="L751">		node.setType(pmdClassLoader.loadClass(className));</span>
<span class="fc" id="L752">		importedClasses.putAll(pmdClassLoader.getImportedClasses(className));</span>
<span class="fc" id="L753">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>