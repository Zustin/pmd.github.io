<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ApexCRUDViolationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Apex</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.apex.rule.security</a> &gt; <span class="el_source">ApexCRUDViolationRule.java</span></div><h1>ApexCRUDViolationRule.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.apex.rule.security;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.apex.ast.ASTAssignmentExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDottedExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTField;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclarationStatements;
import net.sourceforge.pmd.lang.apex.ast.ASTIfElseBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTMethod;
import net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTNewNameValueObjectExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTParameter;
import net.sourceforge.pmd.lang.apex.ast.ASTProperty;
import net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTReturnStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;
import net.sourceforge.pmd.lang.apex.ast.AbstractApexNode;
import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;
import net.sourceforge.pmd.lang.ast.Node;

import apex.jorje.data.ast.Identifier;
import apex.jorje.data.ast.TypeRef;
import apex.jorje.data.ast.TypeRef.ArrayTypeRef;
import apex.jorje.data.ast.TypeRef.ClassTypeRef;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;

/**
 * Finding missed CRUD checks for SOQL and DML operations.
 * 
 * @author sergey.gorbaty
 *
 */
public class ApexCRUDViolationRule extends AbstractApexRule {
<span class="fc" id="L62">    private static final Pattern VOID_OR_STRING_PATTERN = Pattern.compile(&quot;^(string|void)$&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L63">    private static final Pattern SELECT_FROM_PATTERN = Pattern.compile(&quot;[\\S|\\s]+?FROM[\\s]+?(\\w+)&quot;,</span>
            Pattern.CASE_INSENSITIVE);

<span class="fc" id="L66">    private final HashMap&lt;String, String&gt; varToTypeMapping = new HashMap&lt;&gt;();</span>
<span class="fc" id="L67">    private final ListMultimap&lt;String, String&gt; typeToDMLOperationMapping = ArrayListMultimap.create();</span>
<span class="fc" id="L68">    private final HashMap&lt;String, String&gt; checkedTypeToDMLOperationViaESAPI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L69">    private final WeakHashMap&lt;String, ASTMethod&gt; classMethods = new WeakHashMap&lt;&gt;();</span>

    private static final String IS_CREATEABLE = &quot;isCreateable&quot;;
    private static final String IS_DELETABLE = &quot;isDeletable&quot;;
    private static final String IS_UPDATEABLE = &quot;isUpdateable&quot;;
    private static final String IS_MERGEABLE = &quot;isMergeable&quot;;
    private static final String IS_ACCESSIBLE = &quot;isAccessible&quot;;
    private static final String ANY = &quot;ANY&quot;;
    private static final String S_OBJECT_TYPE = &quot;sObjectType&quot;;
    private static final String GET_DESCRIBE = &quot;getDescribe&quot;;

    // ESAPI.accessController().isAuthorizedToView(Lead.sObject, fields)
<span class="fc" id="L81">    private static final String[] ESAPI_ISAUTHORIZED_TO_VIEW = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToView&quot;, };
<span class="fc" id="L83">    private static final String[] ESAPI_ISAUTHORIZED_TO_CREATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToCreate&quot;, };
<span class="fc" id="L85">    private static final String[] ESAPI_ISAUTHORIZED_TO_UPDATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToUpdate&quot;, };
<span class="fc" id="L87">    private static final String[] ESAPI_ISAUTHORIZED_TO_DELETE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToDelete&quot;, };

<span class="fc" id="L90">    private static final String[] RESERVED_KEYS_FLS = new String[] { &quot;Schema&quot;, S_OBJECT_TYPE, };</span>

<span class="fc" id="L92">    public ApexCRUDViolationRule() {</span>
<span class="fc" id="L93">        setProperty(CODECLIMATE_CATEGORIES, new String[] { &quot;Security&quot; });</span>
<span class="fc" id="L94">        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 100);</span>
<span class="fc" id="L95">        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);</span>
<span class="fc" id="L96">    }</span>

    @Override
    public Object visit(ASTUserClass node, Object data) {
<span class="fc bfc" id="L100" title="All 4 branches covered.">        if (Helper.isTestMethodOrClass(node) || Helper.isSystemLevelClass(node)) {</span>
<span class="fc" id="L101">            return data; // stops all the rules</span>
        }

<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (ASTMethod n : node.findDescendantsOfType(ASTMethod.class)) {</span>
<span class="fc" id="L105">            StringBuilder sb = new StringBuilder().append(n.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L106">                    .append(n.getNode().getMethodInfo().getCanonicalName()).append(&quot;:&quot;)</span>
<span class="fc" id="L107">                    .append(n.getNode().getMethodInfo().getParameterTypes().size());</span>
<span class="fc" id="L108">            classMethods.put(sb.toString(), n);</span>
<span class="fc" id="L109">        }</span>

<span class="fc" id="L111">        node.childrenAccept(this, data);</span>
<span class="fc" id="L112">        return data;</span>
    }

    @Override
    public Object visit(ASTMethodCallExpression node, Object data) {
<span class="fc" id="L117">        collectCRUDMethodLevelChecks(node);</span>
<span class="fc" id="L118">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlInsertStatement node, Object data) {
<span class="fc" id="L123">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L124">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlDeleteStatement node, Object data) {
<span class="fc" id="L129">        checkForCRUD(node, data, IS_DELETABLE);</span>
<span class="fc" id="L130">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpdateStatement node, Object data) {
<span class="fc" id="L135">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L136">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpsertStatement node, Object data) {
<span class="fc" id="L141">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L142">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L143">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlMergeStatement node, Object data) {
<span class="nc" id="L148">        checkForCRUD(node, data, IS_MERGEABLE);</span>
<span class="nc" id="L149">        return data;</span>
    }

    @Override
    public Object visit(final ASTAssignmentExpression node, Object data) {
<span class="fc" id="L154">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L156">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L159">        return data;</span>
    }

    @Override
    public Object visit(final ASTVariableDeclaration node, Object data) {
<span class="fc" id="L164">        String type = node.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L165">        addVariableToMapping(Helper.getFQVariableName(node), type);</span>

<span class="fc" id="L167">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L169">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L172">        return data;</span>

    }

    @Override
    public Object visit(final ASTFieldDeclaration node, Object data) {
<span class="fc" id="L178">        ASTFieldDeclarationStatements field = node.getFirstParentOfType(ASTFieldDeclarationStatements.class);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (field != null) {</span>
            try {
<span class="fc" id="L181">                TypeRef a = field.getNode().getTypeName();</span>
<span class="fc" id="L182">                Field classNameField = a.getClass().getDeclaredField(&quot;className&quot;);</span>
<span class="fc" id="L183">                Field typeArgsField = a.getClass().getDeclaredField(&quot;typeArguments&quot;);</span>
<span class="fc" id="L184">                classNameField.setAccessible(true);</span>
<span class="fc" id="L185">                typeArgsField.setAccessible(true);</span>

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                if (classNameField.get(a) instanceof ArrayList&lt;?&gt;) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L189">                    ArrayList&lt;Identifier&gt; innerField = (ArrayList&lt;Identifier&gt;) classNameField.get(a);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                    if (!innerField.isEmpty()) {</span>
<span class="fc" id="L191">                        StringBuffer sb = new StringBuffer();</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                        for (Identifier id : innerField) {</span>
<span class="fc" id="L193">                            sb.append(id.value).append(&quot;.&quot;);</span>
<span class="fc" id="L194">                        }</span>
<span class="fc" id="L195">                        sb.deleteCharAt(sb.length() - 1);</span>

<span class="pc bpc" id="L197" title="2 of 9 branches missed.">                        switch (sb.toString().toLowerCase()) {</span>
                        case &quot;list&quot;:
                        case &quot;map&quot;:
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">                            if (typeArgsField.get(a) instanceof Optional&lt;?&gt;) {</span>
<span class="fc" id="L201">                                addParametersToMapping(node, a, typeArgsField);</span>
                            }
                            break;
                        default:
<span class="fc" id="L205">                            varToTypeMapping.put(Helper.getFQVariableName(node), getSimpleType(sb.toString()));</span>
                            break;
                        }

                    }
                }

<span class="nc" id="L212">            } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException | SecurityException e) {</span>
<span class="nc" id="L213">                e.printStackTrace();</span>
<span class="fc" id="L214">            }</span>

        }
<span class="fc" id="L217">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (soql != null) {</span>
<span class="nc" id="L219">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L222">        return data;</span>

    }

    private void addParametersToMapping(final ASTFieldDeclaration node, TypeRef a, Field typeArgsField)
            throws IllegalAccessException {
<span class="fc" id="L228">        Optional&lt;?&gt; optionalContainer = (Optional&lt;?&gt;) typeArgsField.get(a);</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (optionalContainer.isPresent()) {</span>
<span class="fc" id="L230">            ArrayList&lt;?&gt; inner = (ArrayList&lt;?&gt;) optionalContainer.get();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            for (int i = 0; i &lt; inner.size(); i++) {</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (inner.get(i) instanceof ClassTypeRef) {</span>
<span class="fc" id="L233">                    innerAddParametrizedClassToMapping(node, (ClassTypeRef) inner.get(i));</span>
                }
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if (inner.get(i) instanceof ArrayTypeRef) {</span>
<span class="fc" id="L236">                    ArrayTypeRef atr = (ArrayTypeRef) inner.get(i);</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                    if (atr.heldType instanceof ClassTypeRef) {</span>
<span class="fc" id="L238">                        innerAddParametrizedClassToMapping(node, (ClassTypeRef) atr.heldType);</span>
                    }
                }

            }
        }
<span class="fc" id="L244">    }</span>

    private void innerAddParametrizedClassToMapping(final ASTFieldDeclaration node, final ClassTypeRef innerClassRef) {
<span class="fc" id="L247">        List&lt;Identifier&gt; ids = innerClassRef.className;</span>
<span class="fc" id="L248">        StringBuffer argType = new StringBuffer();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (Identifier id : ids) {</span>
<span class="fc" id="L250">            argType.append(id.value).append(&quot;.&quot;);</span>
<span class="fc" id="L251">        }</span>
<span class="fc" id="L252">        argType.deleteCharAt(argType.length() - 1);</span>
<span class="fc" id="L253">        addVariableToMapping(Helper.getFQVariableName(node), argType.toString());</span>
<span class="fc" id="L254">    }</span>

    @Override
    public Object visit(final ASTReturnStatement node, Object data) {
<span class="fc" id="L258">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L260">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L263">        return data;</span>
    }

    private void addVariableToMapping(final String variableName, final String type) {
<span class="pc bpc" id="L267" title="7 of 9 branches missed.">        switch (type.toLowerCase()) {</span>
        case &quot;list&quot;:
        case &quot;map&quot;:
<span class="nc" id="L270">            return;</span>
        default:
<span class="fc" id="L272">            varToTypeMapping.put(variableName, getSimpleType(type));</span>
        }
<span class="fc" id="L274">    }</span>

    private String getSimpleType(final String type) {
<span class="fc" id="L277">        String typeToUse = type;</span>

<span class="fc" id="L279">        Pattern pattern = Pattern.compile(&quot;^[list&lt;]?list&lt;(\\S+?)&gt;[&gt;]?$&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L280">        Matcher matcher = pattern.matcher(typeToUse);</span>

<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (matcher.find()) {</span>
<span class="fc" id="L283">            typeToUse = matcher.group(1);</span>
        }
<span class="fc" id="L285">        return typeToUse;</span>
    }

    @Override
    public Object visit(final ASTProperty node, Object data) {
<span class="fc" id="L290">        ASTField field = node.getFirstChildOfType(ASTField.class);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (field != null) {</span>
<span class="fc" id="L292">            String fieldType = field.getNode().getFieldInfo().getType().getApexName();</span>
<span class="fc" id="L293">            addVariableToMapping(Helper.getFQVariableName(field), fieldType);</span>
        }

<span class="fc" id="L296">        return data;</span>

    }

    private void collectCRUDMethodLevelChecks(final ASTMethodCallExpression node) {
<span class="fc" id="L301">        final String method = node.getNode().getMethodName();</span>
<span class="fc" id="L302">        final ASTReferenceExpression ref = node.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (ref == null) {</span>
<span class="nc" id="L304">            return;</span>
        }

<span class="fc" id="L307">        List&lt;Identifier&gt; a = ref.getNode().getJadtIdentifiers();</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (!a.isEmpty()) {</span>
<span class="fc" id="L309">            extractObjectAndFields(a, method, node.getNode().getDefiningType().getApexName());</span>
        } else {
            // see if ESAPI
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_VIEW)) {</span>
<span class="fc" id="L313">                extractObjectTypeFromESAPI(node, IS_ACCESSIBLE);</span>
            }

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_CREATE)) {</span>
<span class="nc" id="L317">                extractObjectTypeFromESAPI(node, IS_CREATEABLE);</span>
            }

<span class="fc bfc" id="L320" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_UPDATE)) {</span>
<span class="fc" id="L321">                extractObjectTypeFromESAPI(node, IS_UPDATEABLE);</span>
            }

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_DELETE)) {</span>
<span class="nc" id="L325">                extractObjectTypeFromESAPI(node, IS_DELETABLE);</span>
            }

            // see if getDescribe()
<span class="fc" id="L329">            final ASTDottedExpression dottedExpr = ref.getFirstChildOfType(ASTDottedExpression.class);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (dottedExpr != null) {</span>
<span class="fc" id="L331">                final ASTMethodCallExpression nestedMethodCall = dottedExpr</span>
<span class="fc" id="L332">                        .getFirstChildOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (nestedMethodCall != null) {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    if (isLastMethodName(nestedMethodCall, S_OBJECT_TYPE, GET_DESCRIBE)) {</span>
<span class="fc" id="L335">                        String resolvedType = getType(nestedMethodCall);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                        if (!typeToDMLOperationMapping.get(resolvedType).contains(method)) {</span>
<span class="fc" id="L337">                            typeToDMLOperationMapping.put(resolvedType, method);</span>
                        }
                    }
                }
            }

        }
<span class="fc" id="L344">    }</span>

    private boolean isLastMethodName(final ASTMethodCallExpression methodNode, final String className,
            final String methodName) {
<span class="fc" id="L348">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L350">            if (reference.getNode().getJadtIdentifiers().get(reference.getNode().getJadtIdentifiers().size() - 1).value</span>
<span class="pc bpc" id="L351" title="1 of 4 branches missed.">                    .equalsIgnoreCase(className) &amp;&amp; Helper.isMethodName(methodNode, methodName)) {</span>
<span class="fc" id="L352">                return true;</span>
            }
        }

<span class="fc" id="L356">        return false;</span>
    }

    private String getType(final ASTMethodCallExpression methodNode) {
<span class="fc" id="L360">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L362">            return new StringBuilder().append(reference.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L363">                    .append(reference.getNode().getJadtIdentifiers().get(0).value).toString();</span>
        }
<span class="nc" id="L365">        return &quot;&quot;;</span>
    }

    private void extractObjectAndFields(final List&lt;Identifier&gt; listIdentifiers, final String method,
            final String definingType) {
<span class="fc" id="L370">        final List&lt;String&gt; strings = listIdentifiers.stream().map(id -&gt; id.value).collect(Collectors.toList());</span>

<span class="fc" id="L372">        int flsIndex = Collections.lastIndexOfSubList(strings, Arrays.asList(RESERVED_KEYS_FLS));</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (flsIndex != -1) {</span>
<span class="fc" id="L374">            String objectTypeName = strings.get(flsIndex + RESERVED_KEYS_FLS.length);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (!typeToDMLOperationMapping.get(definingType + &quot;:&quot; + objectTypeName).contains(method)) {</span>
<span class="fc" id="L376">                typeToDMLOperationMapping.put(definingType + &quot;:&quot; + objectTypeName, method);</span>
            }
        }
<span class="fc" id="L379">    }</span>

    private void checkForCRUD(final AbstractApexNode&lt;?&gt; node, final Object data, final String crudMethod) {
<span class="fc" id="L382">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L384">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L385">        }</span>

<span class="fc" id="L387">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L388">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L390" title="3 of 6 branches missed.">        if ((wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="nc" id="L392">            return;</span>
        }

<span class="fc" id="L395">        final ASTNewNameValueObjectExpression newObj = node.getFirstChildOfType(ASTNewNameValueObjectExpression.class);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (newObj != null) {</span>
<span class="fc" id="L397">            final String type = Helper.getFQVariableName(newObj);</span>
<span class="fc" id="L398">            validateCRUDCheckPresent(node, data, crudMethod, type);</span>
        }

<span class="fc" id="L401">        final ASTVariableExpression variable = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (variable != null) {</span>
<span class="fc" id="L403">            final String type = varToTypeMapping.get(Helper.getFQVariableName(variable));</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="fc" id="L405">                StringBuilder typeCheck = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L406">                        .append(&quot;:&quot;).append(type);</span>

<span class="fc" id="L408">                validateCRUDCheckPresent(node, data, crudMethod, typeCheck.toString());</span>
            }
        }
<span class="fc" id="L411">    }</span>

    private HashSet&lt;ASTMethodCallExpression&gt; getPreviousMethodCalls(final AbstractApexNode&lt;?&gt; self) {
<span class="fc" id="L414">        final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls = new HashSet&lt;&gt;();</span>
<span class="fc" id="L415">        final ASTMethod outerMethod = self.getFirstParentOfType(ASTMethod.class);</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (outerMethod != null) {</span>
<span class="fc" id="L417">            final ASTBlockStatement blockStatement = outerMethod.getFirstChildOfType(ASTBlockStatement.class);</span>
<span class="fc" id="L418">            recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, blockStatement);</span>

<span class="fc" id="L420">            final List&lt;ASTMethod&gt; constructorMethods = findConstructorlMethods(self);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">            for (ASTMethod method : constructorMethods) {</span>
<span class="fc" id="L422">                innerMethodCalls.addAll(method.findDescendantsOfType(ASTMethodCallExpression.class));</span>
<span class="fc" id="L423">            }</span>

            // some methods might be within this class
<span class="fc" id="L426">            mapCallToMethodDecl(self, innerMethodCalls, new ArrayList&lt;ASTMethodCallExpression&gt;(innerMethodCalls));</span>
        }

<span class="fc" id="L429">        return innerMethodCalls;</span>
    }

    private void recursivelyEvaluateCRUDMethodCalls(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final ASTBlockStatement blockStatement) {
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (blockStatement != null) {</span>
<span class="fc" id="L435">            int numberOfStatements = blockStatement.jjtGetNumChildren();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfStatements; i++) {</span>
<span class="fc" id="L437">                Node n = blockStatement.jjtGetChild(i);</span>

<span class="fc bfc" id="L439" title="All 2 branches covered.">                if (n instanceof ASTIfElseBlockStatement) {</span>
<span class="fc" id="L440">                    List&lt;ASTBlockStatement&gt; innerBlocks = n.findDescendantsOfType(ASTBlockStatement.class);</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                    for (ASTBlockStatement innerBlock : innerBlocks) {</span>
<span class="fc" id="L442">                        recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, innerBlock);</span>
<span class="fc" id="L443">                    }</span>
                }

<span class="fc" id="L446">                AbstractApexNode&lt;?&gt; match = n.getFirstDescendantOfType(self.getClass());</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">                if (match == self) {</span>
<span class="fc" id="L448">                    break;</span>
                }
<span class="fc" id="L450">                ASTMethodCallExpression methodCall = n.getFirstDescendantOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (methodCall != null) {</span>
<span class="fc" id="L452">                    mapCallToMethodDecl(self, innerMethodCalls, Arrays.asList(methodCall));</span>
                }
            }

        }
<span class="fc" id="L457">    }</span>

    private void mapCallToMethodDecl(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final List&lt;ASTMethodCallExpression&gt; nodes) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (ASTMethodCallExpression node : nodes) {</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (node == self) {</span>
<span class="nc" id="L463">                break;</span>
            }

<span class="fc" id="L466">            final ASTMethod methodBody = resolveMethodCalls(node);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            if (methodBody != null) {</span>
<span class="fc" id="L468">                innerMethodCalls.addAll(methodBody.findDescendantsOfType(ASTMethodCallExpression.class));</span>
            }

<span class="fc" id="L471">        }</span>
<span class="fc" id="L472">    }</span>

    private List&lt;ASTMethod&gt; findConstructorlMethods(final AbstractApexNode&lt;?&gt; node) {
<span class="fc" id="L475">        final ArrayList&lt;ASTMethod&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L476">        final Set&lt;String&gt; constructors = classMethods.keySet().stream()</span>
<span class="fc bfc" id="L477" title="All 4 branches covered.">                .filter(p -&gt; (p.contains(&quot;&lt;init&gt;&quot;) || p.contains(&quot;&lt;clinit&gt;&quot;))).collect(Collectors.toSet());</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">        for (String c : constructors) {</span>
<span class="fc" id="L480">            ret.add(classMethods.get(c));</span>
<span class="fc" id="L481">        }</span>

<span class="fc" id="L483">        return ret;</span>
    }

    private ASTMethod resolveMethodCalls(final ASTMethodCallExpression node) {
<span class="fc" id="L487">        StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L488">                .append(node.getNode().getMethodName()).append(&quot;:&quot;).append(node.getNode().getInputParameters().size());</span>
<span class="fc" id="L489">        return classMethods.get(sb.toString());</span>
    }

    private boolean isProperESAPICheckForDML(final String typeToCheck, final String dmlOperation) {
<span class="fc" id="L493">        final boolean hasMapping = checkedTypeToDMLOperationViaESAPI.containsKey(typeToCheck.toString());</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (hasMapping) {</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            if (dmlOperation.equals(ANY)) {</span>
<span class="fc" id="L496">                return true;</span>
            }

<span class="fc" id="L499">            String dmlChecked = checkedTypeToDMLOperationViaESAPI.get(typeToCheck);</span>
<span class="fc" id="L500">            return dmlChecked.equals(dmlOperation);</span>
        }

<span class="fc" id="L503">        return false;</span>
    }

    private void extractObjectTypeFromESAPI(final ASTMethodCallExpression node, final String dmlOperation) {
<span class="fc" id="L507">        final ASTVariableExpression var = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (var != null) {</span>
<span class="fc" id="L509">            final ASTReferenceExpression reference = var.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            if (reference != null) {</span>
<span class="fc" id="L511">                List&lt;Identifier&gt; identifiers = reference.getNode().getJadtIdentifiers();</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                if (identifiers.size() == 1) {</span>
<span class="fc" id="L513">                    StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L514">                            .append(&quot;:&quot;).append(identifiers.get(0).value);</span>
<span class="fc" id="L515">                    checkedTypeToDMLOperationViaESAPI.put(sb.toString(), dmlOperation);</span>
                }

            }
        }

<span class="fc" id="L521">    }</span>

    private void validateCRUDCheckPresent(final AbstractApexNode&lt;?&gt; node, final Object data, final String crudMethod,
            final String typeCheck) {
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (!typeToDMLOperationMapping.containsKey(typeCheck)) {</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">            if (!isProperESAPICheckForDML(typeCheck, crudMethod)) {</span>
<span class="fc" id="L527">                addViolation(data, node);</span>
            }
        } else {
<span class="fc" id="L530">            boolean properChecksHappened = false;</span>

<span class="fc" id="L532">            List&lt;String&gt; dmlOperationsChecked = typeToDMLOperationMapping.get(typeCheck);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">            for (String dmlOp : dmlOperationsChecked) {</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">                if (dmlOp.equalsIgnoreCase(crudMethod)) {</span>
<span class="fc" id="L535">                    properChecksHappened = true;</span>
<span class="fc" id="L536">                    break;</span>
                }
<span class="fc bfc" id="L538" title="All 2 branches covered.">                if (crudMethod.equals(ANY)) {</span>
<span class="fc" id="L539">                    properChecksHappened = true;</span>
<span class="fc" id="L540">                    break;</span>
                }
<span class="fc" id="L542">            }</span>

<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (!properChecksHappened) {</span>
<span class="fc" id="L545">                addViolation(data, node);</span>
            }
        }
<span class="fc" id="L548">    }</span>

    private void checkForAccessibility(final ASTSoqlExpression node, Object data) {
<span class="fc" id="L551">        final boolean isCount = node.getNode().getCanonicalQuery().startsWith(&quot;SELECT COUNT()&quot;);</span>
<span class="fc" id="L552">        final Set&lt;String&gt; typesFromSOQL = getTypesFromSOQLQuery(node);</span>

<span class="fc" id="L554">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L556">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L557">        }</span>

<span class="fc" id="L559">        boolean isGetter = false;</span>
<span class="fc" id="L560">        String returnType = null;</span>

<span class="fc" id="L562">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L563">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L565" title="3 of 8 branches missed.">        if (isCount || (wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="fc" id="L567">            return;</span>
        }

<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        if (wrappingMethod != null) {</span>
<span class="fc" id="L571">            isGetter = isMethodAGetter(wrappingMethod);</span>
<span class="fc" id="L572">            returnType = getReturnType(wrappingMethod);</span>
        }

<span class="fc" id="L575">        final ASTVariableDeclaration variableDecl = node.getFirstParentOfType(ASTVariableDeclaration.class);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (variableDecl != null) {</span>
<span class="fc" id="L577">            String type = variableDecl.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L578">            type = getSimpleType(type);</span>
<span class="fc" id="L579">            StringBuilder typeCheck = new StringBuilder().append(variableDecl.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L580">                    .append(&quot;:&quot;).append(type);</span>

<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">                if (typesFromSOQL.isEmpty()) {</span>
<span class="nc" id="L584">                    validateCRUDCheckPresent(node, data, ANY, typeCheck.toString());</span>
                } else {
<span class="fc bfc" id="L586" title="All 2 branches covered.">                    for (String typeFromSOQL : typesFromSOQL) {</span>
<span class="fc" id="L587">                        validateCRUDCheckPresent(node, data, ANY, typeFromSOQL);</span>
<span class="fc" id="L588">                    }</span>
                }
            }

        }

<span class="fc" id="L594">        final ASTAssignmentExpression assignment = node.getFirstParentOfType(ASTAssignmentExpression.class);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (assignment != null) {</span>
<span class="fc" id="L596">            final ASTVariableExpression variable = assignment.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">            if (variable != null) {</span>
<span class="fc" id="L598">                String variableWithClass = Helper.getFQVariableName(variable);</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">                if (varToTypeMapping.containsKey(variableWithClass)) {</span>
<span class="fc" id="L600">                    String type = varToTypeMapping.get(variableWithClass);</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">                    if (!isGetter) {</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                        if (typesFromSOQL.isEmpty()) {</span>
<span class="nc" id="L603">                            validateCRUDCheckPresent(node, data, ANY, type);</span>
                        } else {
<span class="fc bfc" id="L605" title="All 2 branches covered.">                            for (String typeFromSOQL : typesFromSOQL) {</span>
<span class="fc" id="L606">                                validateCRUDCheckPresent(node, data, ANY, typeFromSOQL);</span>
<span class="fc" id="L607">                            }</span>
                        }

                    }
                }
            }

        }

<span class="fc" id="L616">        final ASTReturnStatement returnStatement = node.getFirstParentOfType(ASTReturnStatement.class);</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (returnStatement != null) {</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">                if (typesFromSOQL.isEmpty()) {</span>
<span class="nc" id="L620">                    validateCRUDCheckPresent(node, data, ANY, returnType);</span>
                } else {
<span class="fc bfc" id="L622" title="All 2 branches covered.">                    for (String typeFromSOQL : typesFromSOQL) {</span>
<span class="fc" id="L623">                        validateCRUDCheckPresent(node, data, ANY, typeFromSOQL);</span>
<span class="fc" id="L624">                    }</span>
                }
            }
        }
<span class="fc" id="L628">    }</span>

    private Set&lt;String&gt; getTypesFromSOQLQuery(final ASTSoqlExpression node) {
<span class="fc" id="L631">        final Set&lt;String&gt; retVal = new HashSet&lt;&gt;();</span>
<span class="fc" id="L632">        final String canonQuery = node.getNode().getCanonicalQuery();</span>

<span class="fc" id="L634">        Matcher m = SELECT_FROM_PATTERN.matcher(canonQuery);</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L636">            retVal.add(new StringBuffer().append(node.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L637">                    .append(m.group(1)).toString());</span>
        }
<span class="fc" id="L639">        return retVal;</span>
    }

    private String getReturnType(final ASTMethod method) {
<span class="fc" id="L643">        return new StringBuilder().append(method.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L644">                .append(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).toString();</span>
    }

    private boolean isMethodAGetter(final ASTMethod method) {
<span class="fc" id="L648">        final boolean startsWithGet = method.getNode().getMethodInfo().getCanonicalName().startsWith(&quot;get&quot;);</span>
<span class="fc" id="L649">        final boolean voidOrString = VOID_OR_STRING_PATTERN</span>
<span class="fc" id="L650">                .matcher(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).matches();</span>
<span class="fc" id="L651">        final boolean noParams = method.findChildrenOfType(ASTParameter.class).isEmpty();</span>

<span class="fc bfc" id="L653" title="All 6 branches covered.">        return (startsWithGet &amp;&amp; noParams &amp;&amp; !voidOrString);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>