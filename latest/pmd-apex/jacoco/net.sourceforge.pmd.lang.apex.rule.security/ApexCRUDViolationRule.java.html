<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ApexCRUDViolationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Apex</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.apex.rule.security</a> &gt; <span class="el_source">ApexCRUDViolationRule.java</span></div><h1>ApexCRUDViolationRule.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
package net.sourceforge.pmd.lang.apex.rule.security;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import apex.jorje.data.ast.Identifier;
import apex.jorje.data.ast.TypeRef;
import net.sourceforge.pmd.lang.apex.ast.ASTAssignmentExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDottedExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTField;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclarationStatements;
import net.sourceforge.pmd.lang.apex.ast.ASTIfElseBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTMethod;
import net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTNewNameValueObjectExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTParameter;
import net.sourceforge.pmd.lang.apex.ast.ASTProperty;
import net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTReturnStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;
import net.sourceforge.pmd.lang.apex.ast.AbstractApexNode;
import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;
import net.sourceforge.pmd.lang.ast.Node;

/**
 * Finding missed CRUD checks for SOQL and DML operations.
 * 
 * @author sergey.gorbaty
 *
 */
public class ApexCRUDViolationRule extends AbstractApexRule {
<span class="fc" id="L56">    private static final Pattern p = Pattern.compile(&quot;^(string|void)$&quot;, Pattern.CASE_INSENSITIVE);</span>

<span class="fc" id="L58">    private final HashMap&lt;String, String&gt; varToTypeMapping = new HashMap&lt;&gt;();</span>
<span class="fc" id="L59">    private final ListMultimap&lt;String, String&gt; typeToDMLOperationMapping = ArrayListMultimap.create();</span>
<span class="fc" id="L60">    private final HashMap&lt;String, String&gt; checkedTypeToDMLOperationViaESAPI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L61">    private final WeakHashMap&lt;String, ASTMethod&gt; classMethods = new WeakHashMap&lt;&gt;();</span>

    private static final String IS_CREATEABLE = &quot;isCreateable&quot;;
    private static final String IS_DELETABLE = &quot;isDeletable&quot;;
    private static final String IS_UPDATEABLE = &quot;isUpdateable&quot;;
    private static final String IS_MERGEABLE = &quot;isMergeable&quot;;
    private static final String IS_ACCESSIBLE = &quot;isAccessible&quot;;
    private static final String ANY = &quot;ANY&quot;;
    private static final String S_OBJECT_TYPE = &quot;sObjectType&quot;;
    private static final String GET_DESCRIBE = &quot;getDescribe&quot;;

    // ESAPI.accessController().isAuthorizedToView(Lead.sObject, fields)
<span class="fc" id="L73">    private static final String[] ESAPI_ISAUTHORIZED_TO_VIEW = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToView&quot;, };
<span class="fc" id="L75">    private static final String[] ESAPI_ISAUTHORIZED_TO_CREATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToCreate&quot;, };
<span class="fc" id="L77">    private static final String[] ESAPI_ISAUTHORIZED_TO_UPDATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToUpdate&quot;, };
<span class="fc" id="L79">    private static final String[] ESAPI_ISAUTHORIZED_TO_DELETE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToDelete&quot;, };

<span class="fc" id="L82">    private static final String[] RESERVED_KEYS_FLS = new String[] { &quot;Schema&quot;, S_OBJECT_TYPE, };</span>

<span class="fc" id="L84">    public ApexCRUDViolationRule() {</span>
<span class="fc" id="L85">        setProperty(CODECLIMATE_CATEGORIES, new String[] { &quot;Security&quot; });</span>
<span class="fc" id="L86">        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 100);</span>
<span class="fc" id="L87">        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);</span>
<span class="fc" id="L88">    }</span>

    @Override
    public Object visit(ASTUserClass node, Object data) {
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (ASTMethod n : node.findDescendantsOfType(ASTMethod.class)) {</span>
<span class="fc" id="L93">            StringBuilder sb = new StringBuilder().append(n.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L94">                    .append(n.getNode().getMethodInfo().getCanonicalName()).append(&quot;:&quot;)</span>
<span class="fc" id="L95">                    .append(n.getNode().getMethodInfo().getParameterTypes().size());</span>
<span class="fc" id="L96">            classMethods.put(sb.toString(), n);</span>
<span class="fc" id="L97">        }</span>

<span class="fc" id="L99">        node.childrenAccept(this, data);</span>
<span class="fc" id="L100">        return data;</span>
    }

    @Override
    public Object visit(ASTMethodCallExpression node, Object data) {
<span class="fc" id="L105">        collectCRUDMethodLevelChecks(node);</span>
<span class="fc" id="L106">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlInsertStatement node, Object data) {
<span class="fc" id="L111">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L112">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlDeleteStatement node, Object data) {
<span class="fc" id="L117">        checkForCRUD(node, data, IS_DELETABLE);</span>
<span class="fc" id="L118">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpdateStatement node, Object data) {
<span class="fc" id="L123">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L124">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpsertStatement node, Object data) {
<span class="fc" id="L129">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L130">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L131">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlMergeStatement node, Object data) {
<span class="nc" id="L136">        checkForCRUD(node, data, IS_MERGEABLE);</span>
<span class="nc" id="L137">        return data;</span>
    }

    @Override
    public Object visit(final ASTAssignmentExpression node, Object data) {
<span class="fc" id="L142">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L144">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L147">        return data;</span>
    }

    @Override
    public Object visit(final ASTVariableDeclaration node, Object data) {
<span class="fc" id="L152">        String type = node.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L153">        addVariableToMapping(Helper.getFQVariableName(node), type);</span>

<span class="fc" id="L155">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L157">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L160">        return data;</span>

    }

    @Override
    public Object visit(final ASTFieldDeclaration node, Object data) {
<span class="fc" id="L166">        ASTFieldDeclarationStatements field = node.getFirstParentOfType(ASTFieldDeclarationStatements.class);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (field != null) {</span>
            try {
<span class="fc" id="L169">                TypeRef a = field.getNode().getTypeName();</span>
<span class="fc" id="L170">                Field f = a.getClass().getDeclaredField(&quot;className&quot;);</span>
<span class="fc" id="L171">                f.setAccessible(true);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">                if (f.get(a) instanceof ArrayList&lt;?&gt;) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L174">                    ArrayList&lt;Identifier&gt; innerField = (ArrayList&lt;Identifier&gt;) f.get(a);</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                    if (!innerField.isEmpty()) {</span>
<span class="fc" id="L176">                        String type = innerField.get(0).value;</span>
<span class="fc" id="L177">                        addVariableToMapping(Helper.getFQVariableName(node), type);</span>
                    }
                }

<span class="nc" id="L181">            } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException | SecurityException e) {</span>
<span class="fc" id="L182">            }</span>

        }
<span class="fc" id="L185">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (soql != null) {</span>
<span class="nc" id="L187">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L190">        return data;</span>

    }

    @Override
    public Object visit(final ASTReturnStatement node, Object data) {
<span class="fc" id="L196">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L198">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L201">        return data;</span>
    }

    private void addVariableToMapping(final String variableName, final String type) {
<span class="fc" id="L205">        varToTypeMapping.put(variableName, getSimpleType(type));</span>
<span class="fc" id="L206">    }</span>

    private String getSimpleType(final String type) {
<span class="fc" id="L209">        String typeToUse = type;</span>

<span class="fc" id="L211">        Pattern pattern = Pattern.compile(&quot;^[list&lt;]?list&lt;(\\S+?)&gt;[&gt;]?$&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L212">        Matcher matcher = pattern.matcher(typeToUse);</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (matcher.find()) {</span>
<span class="fc" id="L215">            typeToUse = matcher.group(1);</span>
        }
<span class="fc" id="L217">        return typeToUse;</span>
    }

    @Override
    public Object visit(final ASTProperty node, Object data) {
<span class="fc" id="L222">        ASTField field = node.getFirstChildOfType(ASTField.class);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (field != null) {</span>
<span class="fc" id="L224">            String fieldType = field.getNode().getFieldInfo().getType().getApexName();</span>
<span class="fc" id="L225">            addVariableToMapping(Helper.getFQVariableName(field), fieldType);</span>
        }

<span class="fc" id="L228">        return data;</span>

    }

    private void collectCRUDMethodLevelChecks(final ASTMethodCallExpression node) {
<span class="fc" id="L233">        final String method = node.getNode().getMethodName();</span>
<span class="fc" id="L234">        final ASTReferenceExpression ref = node.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (ref == null) {</span>
<span class="nc" id="L236">            return;</span>
        }

<span class="fc" id="L239">        List&lt;Identifier&gt; a = ref.getNode().getJadtIdentifiers();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (!a.isEmpty()) {</span>
<span class="fc" id="L241">            extractObjectAndFields(a, method, node.getNode().getDefiningType().getApexName());</span>
        } else {
            // see if ESAPI
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_VIEW)) {</span>
<span class="fc" id="L245">                extractObjectTypeFromESAPI(node, IS_ACCESSIBLE);</span>
            }

<span class="pc bpc" id="L248" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_CREATE)) {</span>
<span class="nc" id="L249">                extractObjectTypeFromESAPI(node, IS_CREATEABLE);</span>
            }

<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_UPDATE)) {</span>
<span class="fc" id="L253">                extractObjectTypeFromESAPI(node, IS_UPDATEABLE);</span>
            }

<span class="pc bpc" id="L256" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_DELETE)) {</span>
<span class="nc" id="L257">                extractObjectTypeFromESAPI(node, IS_DELETABLE);</span>
            }

            // see if getDescribe()
<span class="fc" id="L261">            final ASTDottedExpression dottedExpr = ref.getFirstChildOfType(ASTDottedExpression.class);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">            if (dottedExpr != null) {</span>
<span class="fc" id="L263">                final ASTMethodCallExpression nestedMethodCall = dottedExpr</span>
<span class="fc" id="L264">                        .getFirstChildOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                if (nestedMethodCall != null) {</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                    if (isLastMethodName(nestedMethodCall, S_OBJECT_TYPE, GET_DESCRIBE)) {</span>
<span class="fc" id="L267">                        String resolvedType = getType(nestedMethodCall);</span>
<span class="fc" id="L268">                        typeToDMLOperationMapping.put(resolvedType, method);</span>
                    }
                }
            }

        }
<span class="fc" id="L274">    }</span>

    private boolean isLastMethodName(final ASTMethodCallExpression methodNode, final String className,
            final String methodName) {
<span class="fc" id="L278">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L280">            if (reference.getNode().getJadtIdentifiers().get(reference.getNode().getJadtIdentifiers().size() - 1).value</span>
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">                    .equalsIgnoreCase(className) &amp;&amp; Helper.isMethodName(methodNode, methodName)) {</span>
<span class="fc" id="L282">                return true;</span>
            }
        }

<span class="fc" id="L286">        return false;</span>
    }

    private String getType(final ASTMethodCallExpression methodNode) {
<span class="fc" id="L290">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L292">            return new StringBuilder().append(reference.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L293">                    .append(reference.getNode().getJadtIdentifiers().get(0).value).toString();</span>
        }
<span class="nc" id="L295">        return &quot;&quot;;</span>
    }

    private void extractObjectAndFields(final List&lt;Identifier&gt; listIdentifiers, final String method,
            final String definingType) {
<span class="fc" id="L300">        final List&lt;String&gt; strings = listIdentifiers.stream().map(id -&gt; id.value).collect(Collectors.toList());</span>

<span class="fc" id="L302">        int flsIndex = Collections.lastIndexOfSubList(strings, Arrays.asList(RESERVED_KEYS_FLS));</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (flsIndex != -1) {</span>
<span class="fc" id="L304">            String objectTypeName = strings.get(flsIndex + RESERVED_KEYS_FLS.length);</span>
<span class="fc" id="L305">            typeToDMLOperationMapping.put(definingType + &quot;:&quot; + objectTypeName, method);</span>
        }
<span class="fc" id="L307">    }</span>

    private void checkForCRUD(final AbstractApexNode&lt;?&gt; node, final Object data, final String crudMethod) {
<span class="fc" id="L310">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L312">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L313">        }</span>

<span class="fc" id="L315">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L316">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L318" title="2 of 6 branches missed.">        if ((wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="fc" id="L320">            return;</span>
        }

<span class="fc" id="L323">        final ASTNewNameValueObjectExpression newObj = node.getFirstChildOfType(ASTNewNameValueObjectExpression.class);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (newObj != null) {</span>
<span class="fc" id="L325">            final String type = Helper.getFQVariableName(newObj);</span>
<span class="fc" id="L326">            validateCRUDCheckPresent(node, data, crudMethod, type);</span>
        }

<span class="fc" id="L329">        final ASTVariableExpression variable = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (variable != null) {</span>
<span class="fc" id="L331">            final String type = varToTypeMapping.get(Helper.getFQVariableName(variable));</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="fc" id="L333">                StringBuilder typeCheck = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L334">                        .append(&quot;:&quot;).append(type);</span>

<span class="fc" id="L336">                validateCRUDCheckPresent(node, data, crudMethod, typeCheck.toString());</span>
            }
        }
<span class="fc" id="L339">    }</span>

    private HashSet&lt;ASTMethodCallExpression&gt; getPreviousMethodCalls(final AbstractApexNode&lt;?&gt; self) {
<span class="fc" id="L342">        final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls = new HashSet&lt;&gt;();</span>
<span class="fc" id="L343">        final ASTMethod outerMethod = self.getFirstParentOfType(ASTMethod.class);</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (outerMethod != null) {</span>
<span class="fc" id="L345">            final ASTBlockStatement blockStatement = outerMethod.getFirstChildOfType(ASTBlockStatement.class);</span>
<span class="fc" id="L346">            recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, blockStatement);</span>

<span class="fc" id="L348">            final List&lt;ASTMethod&gt; constructorMethods = findConstructorlMethods(self);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            for (ASTMethod method : constructorMethods) {</span>
<span class="fc" id="L350">                innerMethodCalls.addAll(method.findDescendantsOfType(ASTMethodCallExpression.class));</span>
<span class="fc" id="L351">            }</span>

            // some methods might be within this class
<span class="fc" id="L354">            mapCallToMethodDecl(self, innerMethodCalls, new ArrayList&lt;ASTMethodCallExpression&gt;(innerMethodCalls));</span>
        }

<span class="fc" id="L357">        return innerMethodCalls;</span>
    }

    private void recursivelyEvaluateCRUDMethodCalls(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final ASTBlockStatement blockStatement) {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (blockStatement != null) {</span>
<span class="fc" id="L363">            int numberOfStatements = blockStatement.jjtGetNumChildren();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfStatements; i++) {</span>
<span class="fc" id="L365">                Node n = blockStatement.jjtGetChild(i);</span>

<span class="fc bfc" id="L367" title="All 2 branches covered.">                if (n instanceof ASTIfElseBlockStatement) {</span>
<span class="fc" id="L368">                    List&lt;ASTBlockStatement&gt; innerBlocks = n.findDescendantsOfType(ASTBlockStatement.class);</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                    for (ASTBlockStatement innerBlock : innerBlocks) {</span>
<span class="fc" id="L370">                        recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, innerBlock);</span>
<span class="fc" id="L371">                    }</span>
                }

<span class="fc" id="L374">                AbstractApexNode&lt;?&gt; match = n.getFirstDescendantOfType(self.getClass());</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if (match == self) {</span>
<span class="fc" id="L376">                    break;</span>
                }
<span class="fc" id="L378">                ASTMethodCallExpression methodCall = n.getFirstDescendantOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                if (methodCall != null) {</span>
<span class="fc" id="L380">                    mapCallToMethodDecl(self, innerMethodCalls, Arrays.asList(methodCall));</span>
                }
            }

        }
<span class="fc" id="L385">    }</span>

    private void mapCallToMethodDecl(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final List&lt;ASTMethodCallExpression&gt; nodes) {
<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (ASTMethodCallExpression node : nodes) {</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">            if (node == self) {</span>
<span class="nc" id="L391">                break;</span>
            }

<span class="fc" id="L394">            final ASTMethod methodBody = resolveMethodCalls(node);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (methodBody != null) {</span>
<span class="fc" id="L396">                innerMethodCalls.addAll(methodBody.findDescendantsOfType(ASTMethodCallExpression.class));</span>
            }

<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">    }</span>

    private List&lt;ASTMethod&gt; findConstructorlMethods(final AbstractApexNode&lt;?&gt; node) {
<span class="fc" id="L403">        final ArrayList&lt;ASTMethod&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L404">        final Set&lt;String&gt; constructors = classMethods.keySet().stream()</span>
<span class="fc bfc" id="L405" title="All 4 branches covered.">                .filter(p -&gt; (p.contains(&quot;&lt;init&gt;&quot;) || p.contains(&quot;&lt;clinit&gt;&quot;))).collect(Collectors.toSet());</span>

<span class="fc bfc" id="L407" title="All 2 branches covered.">        for (String c : constructors) {</span>
<span class="fc" id="L408">            ret.add(classMethods.get(c));</span>
<span class="fc" id="L409">        }</span>

<span class="fc" id="L411">        return ret;</span>
    }

    private ASTMethod resolveMethodCalls(final ASTMethodCallExpression node) {
<span class="fc" id="L415">        StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L416">                .append(node.getNode().getMethodName()).append(&quot;:&quot;).append(node.getNode().getInputParameters().size());</span>
<span class="fc" id="L417">        return classMethods.get(sb.toString());</span>
    }

    private boolean isProperESAPICheckForDML(final String typeToCheck, final String dmlOperation) {
<span class="fc" id="L421">        final boolean hasMapping = checkedTypeToDMLOperationViaESAPI.containsKey(typeToCheck.toString());</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (hasMapping) {</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (dmlOperation.equals(ANY)) {</span>
<span class="fc" id="L424">                return true;</span>
            }

<span class="fc" id="L427">            String dmlChecked = checkedTypeToDMLOperationViaESAPI.get(typeToCheck);</span>
<span class="fc" id="L428">            return dmlChecked.equals(dmlOperation);</span>
        }

<span class="fc" id="L431">        return false;</span>
    }

    private void extractObjectTypeFromESAPI(final ASTMethodCallExpression node, final String dmlOperation) {
<span class="fc" id="L435">        final ASTVariableExpression var = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (var != null) {</span>
<span class="fc" id="L437">            final ASTReferenceExpression reference = var.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">            if (reference != null) {</span>
<span class="fc" id="L439">                List&lt;Identifier&gt; identifiers = reference.getNode().getJadtIdentifiers();</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">                if (identifiers.size() == 1) {</span>
<span class="fc" id="L441">                    StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L442">                            .append(&quot;:&quot;).append(identifiers.get(0).value);</span>
<span class="fc" id="L443">                    checkedTypeToDMLOperationViaESAPI.put(sb.toString(), dmlOperation);</span>
                }

            }
        }

<span class="fc" id="L449">    }</span>

    private void validateCRUDCheckPresent(final AbstractApexNode&lt;?&gt; node, final Object data, final String CRUDMethod,
            final String typeCheck) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (!typeToDMLOperationMapping.containsKey(typeCheck)) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (!isProperESAPICheckForDML(typeCheck, CRUDMethod)) {</span>
<span class="fc" id="L455">                addViolation(data, node);</span>
            }
        } else {
<span class="fc" id="L458">            boolean properChecksHappened = false;</span>

<span class="fc" id="L460">            List&lt;String&gt; dmlOperationsChecked = typeToDMLOperationMapping.get(typeCheck);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            for (String dmlOp : dmlOperationsChecked) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">                if (dmlOp.equalsIgnoreCase(CRUDMethod)) {</span>
<span class="fc" id="L463">                    properChecksHappened = true;</span>
<span class="fc" id="L464">                    break;</span>
                }
<span class="fc bfc" id="L466" title="All 2 branches covered.">                if (CRUDMethod.equals(ANY)) {</span>
<span class="fc" id="L467">                    properChecksHappened = true;</span>
<span class="fc" id="L468">                    break;</span>
                }
<span class="fc" id="L470">            }</span>

<span class="fc bfc" id="L472" title="All 2 branches covered.">            if (!properChecksHappened) {</span>
<span class="fc" id="L473">                addViolation(data, node);</span>
            }
        }
<span class="fc" id="L476">    }</span>

    private void checkForAccessibility(final ASTSoqlExpression node, Object data) {
<span class="fc" id="L479">        final boolean isCount = node.getNode().getCanonicalQuery().startsWith(&quot;SELECT COUNT()&quot;);</span>

<span class="fc" id="L481">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L483">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L484">        }</span>

<span class="fc" id="L486">        boolean isGetter = false;</span>
<span class="fc" id="L487">        String returnType = null;</span>

<span class="fc" id="L489">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L490">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L492" title="3 of 8 branches missed.">        if (isCount || (wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="fc" id="L494">            return;</span>
        }

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (wrappingMethod != null) {</span>
<span class="fc" id="L498">            isGetter = isMethodAGetter(wrappingMethod);</span>
<span class="fc" id="L499">            returnType = getReturnType(wrappingMethod);</span>
        }

<span class="fc" id="L502">        final ASTVariableDeclaration variableDecl = node.getFirstParentOfType(ASTVariableDeclaration.class);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (variableDecl != null) {</span>
<span class="fc" id="L504">            String type = variableDecl.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L505">            type = getSimpleType(type);</span>
<span class="fc" id="L506">            StringBuilder typeCheck = new StringBuilder().append(variableDecl.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L507">                    .append(&quot;:&quot;).append(type);</span>

<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="fc" id="L510">                validateCRUDCheckPresent(node, data, ANY, typeCheck.toString());</span>
            }

        }

<span class="fc" id="L515">        final ASTAssignmentExpression assignment = node.getFirstParentOfType(ASTAssignmentExpression.class);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (assignment != null) {</span>
<span class="fc" id="L517">            final ASTVariableExpression variable = assignment.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">            if (variable != null) {</span>
<span class="fc" id="L519">                String variableWithClass = Helper.getFQVariableName(variable);</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">                if (varToTypeMapping.containsKey(variableWithClass)) {</span>
<span class="fc" id="L521">                    String type = varToTypeMapping.get(variableWithClass);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                    if (!isGetter) {</span>
<span class="fc" id="L523">                        validateCRUDCheckPresent(node, data, ANY, type);</span>
                    }
                }
            }

        }

<span class="fc" id="L530">        final ASTReturnStatement returnStatement = node.getFirstParentOfType(ASTReturnStatement.class);</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (returnStatement != null) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                validateCRUDCheckPresent(node, data, ANY, returnType == null ? &quot;&quot; : returnType);</span>
            }
        }
<span class="fc" id="L536">    }</span>

    private String getReturnType(final ASTMethod method) {
<span class="fc" id="L539">        return new StringBuilder().append(method.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L540">                .append(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).toString();</span>
    }

    private boolean isMethodAGetter(final ASTMethod method) {
<span class="fc" id="L544">        final boolean startsWithGet = method.getNode().getMethodInfo().getCanonicalName().startsWith(&quot;get&quot;);</span>
<span class="fc" id="L545">        final boolean voidOrString = p</span>
<span class="fc" id="L546">                .matcher(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).matches();</span>
<span class="fc" id="L547">        final boolean noParams = method.findChildrenOfType(ASTParameter.class).isEmpty();</span>

<span class="fc bfc" id="L549" title="All 6 branches covered.">        return (startsWithGet &amp;&amp; noParams &amp;&amp; !voidOrString);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>