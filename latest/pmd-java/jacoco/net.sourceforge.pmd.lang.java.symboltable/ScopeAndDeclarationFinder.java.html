<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScopeAndDeclarationFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Java</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.java.symboltable</a> &gt; <span class="el_source">ScopeAndDeclarationFinder.java</span></div><h1>ScopeAndDeclarationFinder.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
package net.sourceforge.pmd.lang.java.symboltable;

import java.util.ArrayDeque;
import java.util.Deque;

import net.sourceforge.pmd.lang.ast.Node;
import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTBlock;
import net.sourceforge.pmd.lang.java.ast.ASTBlockStatement;
import net.sourceforge.pmd.lang.java.ast.ASTCatchStatement;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBodyDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;
import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTFinallyStatement;
import net.sourceforge.pmd.lang.java.ast.ASTForStatement;
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameters;
import net.sourceforge.pmd.lang.java.ast.ASTIfStatement;
import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;
import net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;
import net.sourceforge.pmd.lang.java.ast.ASTTryStatement;
import net.sourceforge.pmd.lang.java.ast.ASTTypeParameters;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.AbstractJavaNode;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;
import net.sourceforge.pmd.lang.symboltable.Scope;


/**
 * Visitor for scope creation.
 * Visits all nodes of an AST and creates scope objects for nodes representing
 * syntactic entities which may contain declarations. For example, a block
 * may contain variable definitions (which are declarations) and
 * therefore needs a scope object where these declarations can be associated,
 * whereas an expression can't contain declarations and therefore doesn't need
 * a scope object.
 * With the exception of global scopes, each scope object is linked to its
 * parent scope, which is the scope object of the next embedding syntactic
 * entity that has a scope.
 */
public class ScopeAndDeclarationFinder extends JavaParserVisitorAdapter {

    private ClassLoader classLoader;

    /**
     * A stack of scopes reflecting the scope hierarchy when a node is visited.
     * This is used to set the parents of the created scopes correctly.
     */
<span class="fc" id="L58">    private Deque&lt;Scope&gt; scopes = new ArrayDeque&lt;&gt;();</span>

    /**
     * Creates a new {@link ScopeAndDeclarationFinder} using the current class loader.
     */
    public ScopeAndDeclarationFinder() {
<span class="fc" id="L64">        this(ScopeAndDeclarationFinder.class.getClassLoader());</span>
<span class="fc" id="L65">    }</span>

    /**
     * Creates a new {@link ScopeAndDeclarationFinder}.
     * @param classLoader the class loader to use to resolve types, see {@link SourceFileScope} and {@link TypeSet}
     */
<span class="fc" id="L71">    public ScopeAndDeclarationFinder(ClassLoader classLoader) {</span>
<span class="fc" id="L72">        this.classLoader = classLoader;</span>
<span class="fc" id="L73">    }</span>

    /**
     * Sets the scope of a node and adjusts the scope stack accordingly.
     * The scope on top of the stack is set as the parent of the given scope,
     * which is then also stored on the scope stack.
     *
     * @param newScope the scope for the node.
     * @param node     the AST node for which the scope is to be set.
     * @throws java.util.EmptyStackException if the scope stack is empty.
     */
    private void addScope(Scope newScope, JavaNode node) {
<span class="fc" id="L85">	newScope.setParent(scopes.peek());</span>
<span class="fc" id="L86">	scopes.push(newScope);</span>
<span class="fc" id="L87">	node.setScope(newScope);</span>
<span class="fc" id="L88">    }</span>

    /**
     * Creates a new local scope for an AST node.
     * The scope on top of the stack is set as the parent of the new scope,
     * which is then also stored on the scope stack.
     *
     * @param node the AST node for which the scope has to be created.
     * @throws java.util.EmptyStackException if the scope stack is empty.
     */
    private void createLocalScope(JavaNode node) {
<span class="fc" id="L99">	addScope(new LocalScope(), node);</span>
<span class="fc" id="L100">    }</span>

    /**
     * Creates a new method scope for an AST node.
     * The scope on top of the stack is set as the parent of the new scope,
     * which is then also stored on the scope stack.
     *
     * @param node the AST node for which the scope has to be created.
     * @throws java.util.EmptyStackException if the scope stack is empty.
     */
    private void createMethodScope(JavaNode node) {
<span class="fc" id="L111">	addScope(new MethodScope(node), node);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Creates a new class scope for an AST node.
     * The scope on top of the stack is set as the parent of the new scope,
     * which is then also stored on the scope stack.
     *
     * @param node the AST node for which the scope has to be created.
     * @throws java.util.EmptyStackException if the scope stack is empty.
     */
    private void createClassScope(JavaNode node) {
<span class="fc bfc" id="L123" title="All 2 branches covered.">	if (node instanceof ASTClassOrInterfaceBodyDeclaration) {</span>
<span class="fc" id="L124">	    addScope(new ClassScope(), node);</span>
	} else {
<span class="fc" id="L126">	    addScope(new ClassScope(node.getImage()), node);</span>
	}
<span class="fc" id="L128">    }</span>

    /**
     * Creates a new global scope for an AST node.
     * The new scope is stored on the scope stack.
     *
     * @param node the AST node for which the scope has to be created.
     */
    private void createSourceFileScope(ASTCompilationUnit node) {
        // When we do full symbol resolution, we'll need to add a truly
        // top-level GlobalScope.
        SourceFileScope scope;
<span class="fc" id="L140">        ASTPackageDeclaration n = node.getPackageDeclaration();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (n != null) {</span>
<span class="fc" id="L142">            scope = new SourceFileScope(n.jjtGetChild(0).getImage());</span>
        } else {
<span class="fc" id="L144">            scope = new SourceFileScope();</span>
        }
<span class="fc" id="L146">        scope.configureImports(classLoader, node.findChildrenOfType(ASTImportDeclaration.class));</span>
<span class="fc" id="L147">        scopes.push(scope);</span>
<span class="fc" id="L148">        node.setScope(scope);</span>
<span class="fc" id="L149">    }</span>

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
<span class="fc" id="L153">	createSourceFileScope(node);</span>
<span class="fc" id="L154">	cont(node);</span>
<span class="fc" id="L155">	return data;</span>
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
<span class="fc" id="L160">	createClassScope(node);</span>
<span class="fc" id="L161">	Scope s = ((JavaNode)node.jjtGetParent()).getScope();</span>
<span class="fc" id="L162">	s.addDeclaration(new ClassNameDeclaration(node));</span>
<span class="fc" id="L163">	cont(node);</span>
<span class="fc" id="L164">	return data;</span>
    }

    @Override
    public Object visit(ASTEnumDeclaration node, Object data) {
<span class="fc" id="L169">	createClassScope(node);</span>
<span class="fc" id="L170">	((ClassScope)node.getScope()).setIsEnum(true);</span>
<span class="fc" id="L171">    Scope s = ((JavaNode)node.jjtGetParent()).getScope();</span>
<span class="fc" id="L172">    s.addDeclaration(new ClassNameDeclaration(node));</span>
<span class="fc" id="L173">	cont(node);</span>
<span class="fc" id="L174">	return data;</span>
    }

    @Override
    public Object visit(ASTAnnotationTypeDeclaration node, Object data) {
<span class="fc" id="L179">	createClassScope(node);</span>
<span class="fc" id="L180">	cont(node);</span>
<span class="fc" id="L181">	return data;</span>
    }

    @Override
    public Object visit(ASTClassOrInterfaceBodyDeclaration node, Object data) {
<span class="fc bfc" id="L186" title="All 4 branches covered.">	if (node.isAnonymousInnerClass() || node.isEnumChild()) {</span>
<span class="fc" id="L187">	    createClassScope(node);</span>
<span class="fc" id="L188">	    cont(node);</span>
	} else {
<span class="fc" id="L190">	    super.visit(node, data);</span>
	}
<span class="fc" id="L192">	return data;</span>
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
<span class="fc" id="L197">	createLocalScope(node);</span>
<span class="fc" id="L198">	cont(node);</span>
<span class="fc" id="L199">	return data;</span>
    }

    @Override
    public Object visit(ASTCatchStatement node, Object data) {
<span class="fc" id="L204">	createLocalScope(node);</span>
<span class="fc" id="L205">	cont(node);</span>
<span class="fc" id="L206">	return data;</span>
    }

    @Override
    public Object visit(ASTFinallyStatement node, Object data) {
<span class="fc" id="L211">	createLocalScope(node);</span>
<span class="fc" id="L212">	cont(node);</span>
<span class="fc" id="L213">	return data;</span>
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
	/*
	 * Local variables declared inside the constructor need to
	 * be in a different scope so special handling is needed
	 */
<span class="fc" id="L222">	createMethodScope(node);</span>

<span class="fc" id="L224">	Scope methodScope = node.getScope();</span>

<span class="fc" id="L226">	Node formalParameters = node.jjtGetChild(0);</span>
<span class="fc" id="L227">	int i = 1;</span>
<span class="fc" id="L228">	int n = node.jjtGetNumChildren();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">	if (!(formalParameters instanceof ASTFormalParameters)) {</span>
<span class="fc" id="L230">	    visit((ASTTypeParameters) formalParameters, data);</span>
<span class="fc" id="L231">	    formalParameters = node.jjtGetChild(1);</span>
<span class="fc" id="L232">	    i++;</span>
	}
<span class="fc" id="L234">	visit((ASTFormalParameters) formalParameters, data);</span>

<span class="fc" id="L236">	Scope localScope = null;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">	for (; i &lt; n; i++) {</span>
<span class="fc" id="L238">	    JavaNode b = (JavaNode) node.jjtGetChild(i);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">	    if (b instanceof ASTBlockStatement) {</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (localScope == null) {</span>
<span class="fc" id="L241">		    createLocalScope(node);</span>
<span class="fc" id="L242">		    localScope = node.getScope();</span>
		}
<span class="fc" id="L244">		b.setScope(localScope);</span>
<span class="fc" id="L245">		visit(b, data);</span>
	    } else {
<span class="fc" id="L247">		visit(b, data);</span>
	    }
	}
<span class="fc bfc" id="L250" title="All 2 branches covered.">	if (localScope != null) {</span>
	    // pop the local scope
<span class="fc" id="L252">	    scopes.pop();</span>

	    // reset the correct scope for the constructor
<span class="fc" id="L255">	    node.setScope(methodScope);</span>
	}
	// pop the method scope
<span class="fc" id="L258">	scopes.pop();</span>

<span class="fc" id="L260">	return data;</span>
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
<span class="fc" id="L265">	createMethodScope(node);</span>
<span class="fc" id="L266">	ASTMethodDeclarator md = node.getFirstChildOfType(ASTMethodDeclarator.class);</span>
<span class="fc" id="L267">	node.getScope().getEnclosingScope(ClassScope.class).addDeclaration(new MethodNameDeclaration(md));</span>
<span class="fc" id="L268">	cont(node);</span>
<span class="fc" id="L269">	return data;</span>
    }

    @Override
    public Object visit(ASTLambdaExpression node, Object data) {
<span class="fc" id="L274">        createLocalScope(node);</span>
<span class="fc" id="L275">        cont(node);</span>
<span class="fc" id="L276">        return data;</span>
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
<span class="fc" id="L281">	createLocalScope(node);</span>
<span class="fc" id="L282">	cont(node);</span>
<span class="fc" id="L283">	return data;</span>
    }

    // TODO - what about while loops and do loops?
    @Override
    public Object visit(ASTForStatement node, Object data) {
<span class="fc" id="L289">	createLocalScope(node);</span>
<span class="fc" id="L290">	cont(node);</span>
<span class="fc" id="L291">	return data;</span>
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
<span class="fc" id="L296">	createLocalScope(node);</span>
<span class="fc" id="L297">	cont(node);</span>
<span class="fc" id="L298">	return data;</span>
    }

    @Override
    public Object visit(ASTVariableDeclaratorId node, Object data) {
<span class="fc" id="L303">	VariableNameDeclaration decl = new VariableNameDeclaration(node);</span>
<span class="fc" id="L304">	node.getScope().addDeclaration(decl);</span>
<span class="fc" id="L305">	node.setNameDeclaration(decl);</span>
<span class="fc" id="L306">	return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
<span class="fc" id="L311">	createLocalScope(node);</span>
<span class="fc" id="L312">	cont(node);</span>
<span class="fc" id="L313">	return data;</span>
    }

    private void cont(AbstractJavaNode node) {
<span class="fc" id="L317">	super.visit(node, null);</span>
<span class="fc" id="L318">	scopes.pop();</span>
<span class="fc" id="L319">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>