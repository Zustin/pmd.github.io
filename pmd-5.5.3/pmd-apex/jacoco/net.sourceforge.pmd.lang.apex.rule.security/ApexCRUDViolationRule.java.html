<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ApexCRUDViolationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Apex</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.apex.rule.security</a> &gt; <span class="el_source">ApexCRUDViolationRule.java</span></div><h1>ApexCRUDViolationRule.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
package net.sourceforge.pmd.lang.apex.rule.security;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import apex.jorje.data.ast.Identifier;
import net.sourceforge.pmd.lang.apex.ast.ASTAssignmentExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDottedExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTField;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTIfElseBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTMethod;
import net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTNewNameValueObjectExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTProperty;
import net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTReturnStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;
import net.sourceforge.pmd.lang.apex.ast.AbstractApexNode;
import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;
import net.sourceforge.pmd.lang.ast.Node;

/**
 * Finding missed CRUD checks for SOQL and DML operations.
 * 
 * @author sergey.gorbaty
 *
 */
public class ApexCRUDViolationRule extends AbstractApexRule {
<span class="fc" id="L52">    private static final Pattern p = Pattern.compile(&quot;^(string|void)$&quot;, Pattern.CASE_INSENSITIVE);</span>

<span class="fc" id="L54">    private final HashMap&lt;String, String&gt; varToTypeMapping = new HashMap&lt;&gt;();</span>
<span class="fc" id="L55">    private final ListMultimap&lt;String, String&gt; typeToDMLOperationMapping = ArrayListMultimap.create();</span>
<span class="fc" id="L56">    private final HashMap&lt;String, String&gt; checkedTypeToDMLOperationViaESAPI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L57">    private final WeakHashMap&lt;String, ASTMethod&gt; classMethods = new WeakHashMap&lt;&gt;();</span>

    private static final String IS_CREATEABLE = &quot;isCreateable&quot;;
    private static final String IS_DELETABLE = &quot;isDeletable&quot;;
    private static final String IS_UPDATEABLE = &quot;isUpdateable&quot;;
    private static final String IS_MERGEABLE = &quot;isMergeable&quot;;
    private static final String IS_ACCESSIBLE = &quot;isAccessible&quot;;
    private static final String ANY = &quot;ANY&quot;;
    private static final String S_OBJECT_TYPE = &quot;sObjectType&quot;;
    private static final String GET_DESCRIBE = &quot;getDescribe&quot;;

    // ESAPI.accessController().isAuthorizedToView(Lead.sObject, fields)
<span class="fc" id="L69">    private static final String[] ESAPI_ISAUTHORIZED_TO_VIEW = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToView&quot;, };
<span class="fc" id="L71">    private static final String[] ESAPI_ISAUTHORIZED_TO_CREATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToCreate&quot;, };
<span class="fc" id="L73">    private static final String[] ESAPI_ISAUTHORIZED_TO_UPDATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToUpdate&quot;, };
<span class="fc" id="L75">    private static final String[] ESAPI_ISAUTHORIZED_TO_DELETE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToDelete&quot;, };

<span class="fc" id="L78">    private static final String[] RESERVED_KEYS_FLS = new String[] { &quot;Schema&quot;, S_OBJECT_TYPE, };</span>

<span class="fc" id="L80">    public ApexCRUDViolationRule() {</span>
<span class="fc" id="L81">        setProperty(CODECLIMATE_CATEGORIES, new String[] { &quot;Security&quot; });</span>
<span class="fc" id="L82">        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 100);</span>
<span class="fc" id="L83">        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);</span>
<span class="fc" id="L84">    }</span>

    @Override
    public Object visit(ASTUserClass node, Object data) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (ASTMethod n : node.findDescendantsOfType(ASTMethod.class)) {</span>
<span class="fc" id="L89">            StringBuilder sb = new StringBuilder().append(n.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L90">                    .append(n.getNode().getMethodInfo().getCanonicalName()).append(&quot;:&quot;)</span>
<span class="fc" id="L91">                    .append(n.getNode().getMethodInfo().getParameterTypes().size());</span>
<span class="fc" id="L92">            classMethods.put(sb.toString(), n);</span>
<span class="fc" id="L93">        }</span>

<span class="fc" id="L95">        node.childrenAccept(this, data);</span>
<span class="fc" id="L96">        return data;</span>
    }

    @Override
    public Object visit(ASTMethodCallExpression node, Object data) {
<span class="fc" id="L101">        collectCRUDMethodLevelChecks(node);</span>
<span class="fc" id="L102">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlInsertStatement node, Object data) {
<span class="fc" id="L107">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L108">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlDeleteStatement node, Object data) {
<span class="fc" id="L113">        checkForCRUD(node, data, IS_DELETABLE);</span>
<span class="fc" id="L114">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpdateStatement node, Object data) {
<span class="fc" id="L119">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L120">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpsertStatement node, Object data) {
<span class="fc" id="L125">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L126">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L127">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlMergeStatement node, Object data) {
<span class="nc" id="L132">        checkForCRUD(node, data, IS_MERGEABLE);</span>
<span class="nc" id="L133">        return data;</span>
    }

    @Override
    public Object visit(final ASTAssignmentExpression node, Object data) {
<span class="fc" id="L138">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L140">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L143">        return data;</span>
    }

    @Override
    public Object visit(final ASTVariableDeclaration node, Object data) {
<span class="fc" id="L148">        String type = node.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L149">        addVariableToMapping(Helper.getFQVariableName(node), type);</span>

<span class="fc" id="L151">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L153">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L156">        return data;</span>

    }

    @Override
    public Object visit(final ASTFieldDeclaration node, Object data) {
<span class="nc" id="L162">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (soql != null) {</span>
<span class="nc" id="L164">            checkForAccessibility(soql, data);</span>
        }

<span class="nc" id="L167">        return data;</span>

    }

    @Override
    public Object visit(final ASTReturnStatement node, Object data) {
<span class="fc" id="L173">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L175">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L178">        return data;</span>
    }

    private void addVariableToMapping(final String variableName, final String type) {
<span class="fc" id="L182">        varToTypeMapping.put(variableName, getSimpleType(type));</span>
<span class="fc" id="L183">    }</span>

    private String getSimpleType(final String type) {
<span class="fc" id="L186">        String typeToUse = type;</span>

<span class="fc" id="L188">        Pattern pattern = Pattern.compile(&quot;^[list&lt;]?list&lt;(\\S+?)&gt;[&gt;]?$&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L189">        Matcher matcher = pattern.matcher(typeToUse);</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (matcher.find()) {</span>
<span class="fc" id="L192">            typeToUse = matcher.group(1);</span>
        }
<span class="fc" id="L194">        return typeToUse;</span>
    }

    @Override
    public Object visit(final ASTProperty node, Object data) {
<span class="fc" id="L199">        ASTField field = node.getFirstChildOfType(ASTField.class);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (field != null) {</span>
<span class="fc" id="L201">            String fieldType = field.getNode().getFieldInfo().getType().getApexName();</span>
<span class="fc" id="L202">            addVariableToMapping(Helper.getFQVariableName(field), fieldType);</span>
        }

<span class="fc" id="L205">        return data;</span>

    }

    private void collectCRUDMethodLevelChecks(final ASTMethodCallExpression node) {
<span class="fc" id="L210">        final String method = node.getNode().getMethodName();</span>
<span class="fc" id="L211">        final ASTReferenceExpression ref = node.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (ref == null) {</span>
<span class="nc" id="L213">            return;</span>
        }

<span class="fc" id="L216">        List&lt;Identifier&gt; a = ref.getNode().getJadtIdentifiers();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (!a.isEmpty()) {</span>
<span class="fc" id="L218">            extractObjectAndFields(a, method, node.getNode().getDefiningType().getApexName());</span>
        } else {
            // see if ESAPI
<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_VIEW)) {</span>
<span class="fc" id="L222">                extractObjectTypeFromESAPI(node, IS_ACCESSIBLE);</span>
            }

<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_CREATE)) {</span>
<span class="nc" id="L226">                extractObjectTypeFromESAPI(node, IS_CREATEABLE);</span>
            }

<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_UPDATE)) {</span>
<span class="fc" id="L230">                extractObjectTypeFromESAPI(node, IS_UPDATEABLE);</span>
            }

<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_DELETE)) {</span>
<span class="nc" id="L234">                extractObjectTypeFromESAPI(node, IS_DELETABLE);</span>
            }

            // see if getDescribe()
<span class="fc" id="L238">            final ASTDottedExpression dottedExpr = ref.getFirstChildOfType(ASTDottedExpression.class);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            if (dottedExpr != null) {</span>
<span class="fc" id="L240">                final ASTMethodCallExpression nestedMethodCall = dottedExpr</span>
<span class="fc" id="L241">                        .getFirstChildOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                if (nestedMethodCall != null) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">                    if (isLastMethodName(nestedMethodCall, S_OBJECT_TYPE, GET_DESCRIBE)) {</span>
<span class="fc" id="L244">                        String resolvedType = getType(nestedMethodCall);</span>
<span class="fc" id="L245">                        typeToDMLOperationMapping.put(resolvedType, method);</span>
                    }
                }
            }

        }
<span class="fc" id="L251">    }</span>

    private boolean isLastMethodName(final ASTMethodCallExpression methodNode, final String className,
            final String methodName) {
<span class="fc" id="L255">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L257">            if (reference.getNode().getJadtIdentifiers().get(reference.getNode().getJadtIdentifiers().size() - 1).value</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">                    .equalsIgnoreCase(className) &amp;&amp; Helper.isMethodName(methodNode, methodName)) {</span>
<span class="fc" id="L259">                return true;</span>
            }
        }

<span class="fc" id="L263">        return false;</span>
    }

    private String getType(final ASTMethodCallExpression methodNode) {
<span class="fc" id="L267">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L269">            return new StringBuilder().append(reference.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L270">                    .append(reference.getNode().getJadtIdentifiers().get(0).value).toString();</span>
        }
<span class="nc" id="L272">        return &quot;&quot;;</span>
    }

    private void extractObjectAndFields(final List&lt;Identifier&gt; listIdentifiers, final String method,
            final String definingType) {
<span class="fc" id="L277">        final List&lt;String&gt; strings = listIdentifiers.stream().map(id -&gt; id.value).collect(Collectors.toList());</span>

<span class="fc" id="L279">        int flsIndex = Collections.lastIndexOfSubList(strings, Arrays.asList(RESERVED_KEYS_FLS));</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (flsIndex != -1) {</span>
<span class="fc" id="L281">            String objectTypeName = strings.get(flsIndex + RESERVED_KEYS_FLS.length);</span>
<span class="fc" id="L282">            typeToDMLOperationMapping.put(definingType + &quot;:&quot; + objectTypeName, method);</span>
        }
<span class="fc" id="L284">    }</span>

    private void checkForCRUD(final AbstractApexNode&lt;?&gt; node, final Object data, final String crudMethod) {
<span class="fc" id="L287">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L289">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L290">        }</span>

<span class="fc" id="L292">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L293">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L295" title="2 of 6 branches missed.">        if ((wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="fc" id="L297">            return;</span>
        }

<span class="fc" id="L300">        final ASTNewNameValueObjectExpression newObj = node.getFirstChildOfType(ASTNewNameValueObjectExpression.class);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (newObj != null) {</span>
<span class="fc" id="L302">            final String type = Helper.getFQVariableName(newObj);</span>
<span class="fc" id="L303">            validateCRUDCheckPresent(node, data, crudMethod, type);</span>
        }

<span class="fc" id="L306">        final ASTVariableExpression variable = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (variable != null) {</span>
<span class="fc" id="L308">            final String type = varToTypeMapping.get(Helper.getFQVariableName(variable));</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="fc" id="L310">                StringBuilder typeCheck = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L311">                        .append(&quot;:&quot;).append(type);</span>

<span class="fc" id="L313">                validateCRUDCheckPresent(node, data, crudMethod, typeCheck.toString());</span>
            }
        }
<span class="fc" id="L316">    }</span>

    private HashSet&lt;ASTMethodCallExpression&gt; getPreviousMethodCalls(final AbstractApexNode&lt;?&gt; self) {
<span class="fc" id="L319">        final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls = new HashSet&lt;&gt;();</span>
<span class="fc" id="L320">        final ASTMethod outerMethod = self.getFirstParentOfType(ASTMethod.class);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (outerMethod != null) {</span>
<span class="fc" id="L322">            final ASTBlockStatement blockStatement = outerMethod.getFirstChildOfType(ASTBlockStatement.class);</span>
<span class="fc" id="L323">            recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, blockStatement);</span>

<span class="fc" id="L325">            final List&lt;ASTMethod&gt; constructorMethods = findConstructorlMethods(self);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            for (ASTMethod method : constructorMethods) {</span>
<span class="fc" id="L327">                innerMethodCalls.addAll(method.findDescendantsOfType(ASTMethodCallExpression.class));</span>
<span class="fc" id="L328">            }</span>

            // some methods might be within this class
<span class="fc" id="L331">            mapCallToMethodDecl(self, innerMethodCalls, new ArrayList&lt;ASTMethodCallExpression&gt;(innerMethodCalls));</span>
        }

<span class="fc" id="L334">        return innerMethodCalls;</span>
    }

    private void recursivelyEvaluateCRUDMethodCalls(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final ASTBlockStatement blockStatement) {
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (blockStatement != null) {</span>
<span class="fc" id="L340">            int numberOfStatements = blockStatement.jjtGetNumChildren();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfStatements; i++) {</span>
<span class="fc" id="L342">                Node n = blockStatement.jjtGetChild(i);</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">                if (n instanceof ASTIfElseBlockStatement) {</span>
<span class="fc" id="L345">                    List&lt;ASTBlockStatement&gt; innerBlocks = n.findDescendantsOfType(ASTBlockStatement.class);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    for (ASTBlockStatement innerBlock : innerBlocks) {</span>
<span class="fc" id="L347">                        recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, innerBlock);</span>
<span class="fc" id="L348">                    }</span>
                }

<span class="fc" id="L351">                AbstractApexNode&lt;?&gt; match = n.getFirstDescendantOfType(self.getClass());</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                if (match == self) {</span>
<span class="fc" id="L353">                    break;</span>
                }
<span class="fc" id="L355">                ASTMethodCallExpression methodCall = n.getFirstDescendantOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                if (methodCall != null) {</span>
<span class="fc" id="L357">                    mapCallToMethodDecl(self, innerMethodCalls, Arrays.asList(methodCall));</span>
                }
            }

        }
<span class="fc" id="L362">    }</span>

    private void mapCallToMethodDecl(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final List&lt;ASTMethodCallExpression&gt; nodes) {
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (ASTMethodCallExpression node : nodes) {</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (node == self) {</span>
<span class="nc" id="L368">                break;</span>
            }

<span class="fc" id="L371">            final ASTMethod methodBody = resolveMethodCalls(node);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (methodBody != null) {</span>
<span class="fc" id="L373">                innerMethodCalls.addAll(methodBody.findDescendantsOfType(ASTMethodCallExpression.class));</span>
            }

<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">    }</span>

    private List&lt;ASTMethod&gt; findConstructorlMethods(final AbstractApexNode&lt;?&gt; node) {
<span class="fc" id="L380">        final ArrayList&lt;ASTMethod&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L381">        final Set&lt;String&gt; constructors = classMethods.keySet().stream()</span>
<span class="fc bfc" id="L382" title="All 4 branches covered.">                .filter(p -&gt; (p.contains(&quot;&lt;init&gt;&quot;) || p.contains(&quot;&lt;clinit&gt;&quot;))).collect(Collectors.toSet());</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (String c : constructors) {</span>
<span class="fc" id="L385">            ret.add(classMethods.get(c));</span>
<span class="fc" id="L386">        }</span>

<span class="fc" id="L388">        return ret;</span>
    }

    private ASTMethod resolveMethodCalls(final ASTMethodCallExpression node) {
<span class="fc" id="L392">        StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L393">                .append(node.getNode().getMethodName()).append(&quot;:&quot;).append(node.getNode().getInputParameters().size());</span>
<span class="fc" id="L394">        return classMethods.get(sb.toString());</span>
    }

    private boolean isProperESAPICheckForDML(final String typeToCheck, final String dmlOperation) {
<span class="fc" id="L398">        final boolean hasMapping = checkedTypeToDMLOperationViaESAPI.containsKey(typeToCheck.toString());</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (hasMapping) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">            if (dmlOperation.equals(ANY)) {</span>
<span class="fc" id="L401">                return true;</span>
            }

<span class="fc" id="L404">            String dmlChecked = checkedTypeToDMLOperationViaESAPI.get(typeToCheck);</span>
<span class="fc" id="L405">            return dmlChecked.equals(dmlOperation);</span>
        }

<span class="fc" id="L408">        return false;</span>
    }

    private void extractObjectTypeFromESAPI(final ASTMethodCallExpression node, final String dmlOperation) {
<span class="fc" id="L412">        final ASTVariableExpression var = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (var != null) {</span>
<span class="fc" id="L414">            final ASTReferenceExpression reference = var.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            if (reference != null) {</span>
<span class="fc" id="L416">                List&lt;Identifier&gt; identifiers = reference.getNode().getJadtIdentifiers();</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                if (identifiers.size() == 1) {</span>
<span class="fc" id="L418">                    StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L419">                            .append(&quot;:&quot;).append(identifiers.get(0).value);</span>
<span class="fc" id="L420">                    checkedTypeToDMLOperationViaESAPI.put(sb.toString(), dmlOperation);</span>
                }

            }
        }

<span class="fc" id="L426">    }</span>

    private void validateCRUDCheckPresent(final AbstractApexNode&lt;?&gt; node, final Object data, final String CRUDMethod,
            final String typeCheck) {
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (!typeToDMLOperationMapping.containsKey(typeCheck)) {</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (!isProperESAPICheckForDML(typeCheck, CRUDMethod)) {</span>
<span class="fc" id="L432">                addViolation(data, node);</span>
            }
        } else {
<span class="fc" id="L435">            boolean properChecksHappened = false;</span>

<span class="fc" id="L437">            List&lt;String&gt; dmlOperationsChecked = typeToDMLOperationMapping.get(typeCheck);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            for (String dmlOp : dmlOperationsChecked) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">                if (dmlOp.equalsIgnoreCase(CRUDMethod)) {</span>
<span class="fc" id="L440">                    properChecksHappened = true;</span>
<span class="fc" id="L441">                    break;</span>
                }
<span class="fc bfc" id="L443" title="All 2 branches covered.">                if (CRUDMethod.equals(ANY)) {</span>
<span class="fc" id="L444">                    properChecksHappened = true;</span>
<span class="fc" id="L445">                    break;</span>
                }
<span class="fc" id="L447">            }</span>

<span class="fc bfc" id="L449" title="All 2 branches covered.">            if (!properChecksHappened) {</span>
<span class="fc" id="L450">                addViolation(data, node);</span>
            }
        }
<span class="fc" id="L453">    }</span>

    private void checkForAccessibility(final ASTSoqlExpression node, Object data) {
<span class="fc" id="L456">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L458">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L459">        }</span>

<span class="fc" id="L461">        boolean isGetter = false;</span>
<span class="fc" id="L462">        String returnType = null;</span>

<span class="fc" id="L464">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L465">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L467" title="3 of 6 branches missed.">        if ((wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="nc" id="L469">            return;</span>
        }

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (wrappingMethod != null) {</span>
<span class="fc" id="L473">            isGetter = isMethodAGetter(wrappingMethod);</span>
<span class="fc" id="L474">            returnType = getReturnType(wrappingMethod);</span>
        }

<span class="fc" id="L477">        final ASTVariableDeclaration variableDecl = node.getFirstParentOfType(ASTVariableDeclaration.class);</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (variableDecl != null) {</span>
<span class="fc" id="L479">            String type = variableDecl.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L480">            type = getSimpleType(type);</span>
<span class="fc" id="L481">            StringBuilder typeCheck = new StringBuilder().append(variableDecl.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L482">                    .append(&quot;:&quot;).append(type);</span>

<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="fc" id="L485">                validateCRUDCheckPresent(node, data, ANY, typeCheck.toString());</span>
            }

        }

<span class="fc" id="L490">        final ASTAssignmentExpression assignment = node.getFirstParentOfType(ASTAssignmentExpression.class);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (assignment != null) {</span>
<span class="fc" id="L492">            final ASTVariableExpression variable = assignment.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            if (variable != null) {</span>
<span class="fc" id="L494">                String variableWithClass = Helper.getFQVariableName(variable);</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">                if (varToTypeMapping.containsKey(variableWithClass)) {</span>
<span class="fc" id="L496">                    String type = varToTypeMapping.get(variableWithClass);</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">                    if (!isGetter) {</span>
<span class="fc" id="L498">                        validateCRUDCheckPresent(node, data, ANY, type);</span>
                    }
                }
            }

        }

<span class="fc" id="L505">        final ASTReturnStatement returnStatement = node.getFirstParentOfType(ASTReturnStatement.class);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (returnStatement != null) {</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                validateCRUDCheckPresent(node, data, ANY, returnType == null ? &quot;&quot; : returnType);</span>
            }
        }
<span class="fc" id="L511">    }</span>

    private String getReturnType(final ASTMethod method) {
<span class="fc" id="L514">        return new StringBuilder().append(method.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L515">                .append(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).toString();</span>
    }

    private boolean isMethodAGetter(final ASTMethod method) {
<span class="fc" id="L519">        final boolean startsWithGet = method.getNode().getMethodInfo().getCanonicalName().startsWith(&quot;get&quot;);</span>
<span class="fc" id="L520">        final boolean voidOrString = p</span>
<span class="fc" id="L521">                .matcher(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).matches();</span>

<span class="fc bfc" id="L523" title="All 4 branches covered.">        return (startsWithGet &amp;&amp; !voidOrString);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>