<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RuleSetFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Core</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd</a> &gt; <span class="el_source">RuleSetFactory.java</span></div><h1>RuleSetFactory.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.Adler32;
import java.util.zip.CheckedInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import net.sourceforge.pmd.RuleSet.RuleSetBuilder;
import net.sourceforge.pmd.lang.Language;
import net.sourceforge.pmd.lang.LanguageRegistry;
import net.sourceforge.pmd.lang.LanguageVersion;
import net.sourceforge.pmd.lang.rule.MockRule;
import net.sourceforge.pmd.lang.rule.RuleReference;
import net.sourceforge.pmd.lang.rule.XPathRule;
import net.sourceforge.pmd.lang.rule.properties.PropertyDescriptorWrapper;
import net.sourceforge.pmd.lang.rule.properties.factories.PropertyDescriptorUtil;
import net.sourceforge.pmd.util.ResourceLoader;
import net.sourceforge.pmd.util.StringUtil;

/**
 * RuleSetFactory is responsible for creating RuleSet instances from XML
 * content. By default Rules will be loaded using the ClassLoader for this
 * class, using the {@link RulePriority#LOW} priority, with Rule deprecation
 * warnings off. By default, the ruleset compatibility filter is active, too.
 * See {@link RuleSetFactoryCompatibility}.
 */
public class RuleSetFactory {

<span class="fc" id="L55">    private static final Logger LOG = Logger.getLogger(RuleSetFactory.class.getName());</span>

    private static final String DESCRIPTION = &quot;description&quot;;
    private static final String UNEXPECTED_ELEMENT = &quot;Unexpected element &lt;&quot;;
    private static final String PRIORITY = &quot;priority&quot;;
    private static final String FOR_RULE = &quot;' for Rule &quot;;
    private static final String MESSAGE = &quot;message&quot;;
    private static final String EXTERNAL_INFO_URL = &quot;externalInfoUrl&quot;;

    private final ClassLoader classLoader;
    private final RulePriority minimumPriority;
    private final boolean warnDeprecated;
    private final RuleSetFactoryCompatibility compatibilityFilter;

    public RuleSetFactory() {
<span class="fc" id="L70">        this(RuleSetFactory.class.getClassLoader(), RulePriority.LOW, false, true);</span>
<span class="fc" id="L71">    }</span>

    public RuleSetFactory(final ClassLoader classLoader, final RulePriority minimumPriority,
<span class="fc" id="L74">            final boolean warnDeprecated, final boolean enableCompatibility) {</span>
<span class="fc" id="L75">        this.classLoader = classLoader;</span>
<span class="fc" id="L76">        this.minimumPriority = minimumPriority;</span>
<span class="fc" id="L77">        this.warnDeprecated = warnDeprecated;</span>

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (enableCompatibility) {</span>
<span class="fc" id="L80">            this.compatibilityFilter = new RuleSetFactoryCompatibility();</span>
        } else {
<span class="nc" id="L82">            this.compatibilityFilter = null;</span>
        }
<span class="fc" id="L84">    }</span>

    /**
     * Constructor copying all configuration from another factory.
     * 
     * @param factory
     *            The factory whose configuration to copy.
     * @param warnDeprecated
     *            Whether deprecation warnings are to be produced by this
     *            factory.
     */
    public RuleSetFactory(final RuleSetFactory factory, final boolean warnDeprecated) {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        this(factory.classLoader, factory.minimumPriority, warnDeprecated, factory.compatibilityFilter != null);</span>
<span class="fc" id="L97">    }</span>

    /**
     * Gets the compatibility filter in order to adjust it, e.g. add additional
     * filters.
     *
     * @return the {@link RuleSetFactoryCompatibility}
     */
    /* package */ RuleSetFactoryCompatibility getCompatibilityFilter() {
<span class="fc" id="L106">        return compatibilityFilter;</span>
    }

    /**
     * Returns an Iterator of RuleSet objects loaded from descriptions from the
     * &quot;rulesets.properties&quot; resource for each Language with Rule support.
     *
     * @return An Iterator of RuleSet objects.
     * 
     * @throws RuleSetNotFoundException if the ruleset file could not be found
     */
    public Iterator&lt;RuleSet&gt; getRegisteredRuleSets() throws RuleSetNotFoundException {
<span class="nc" id="L118">        String rulesetsProperties = null;</span>
        try {
<span class="nc" id="L120">            List&lt;RuleSetReferenceId&gt; ruleSetReferenceIds = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            for (Language language : LanguageRegistry.findWithRuleSupport()) {</span>
<span class="nc" id="L122">                Properties props = new Properties();</span>
<span class="nc" id="L123">                rulesetsProperties = &quot;rulesets/&quot; + language.getTerseName() + &quot;/rulesets.properties&quot;;</span>
<span class="nc" id="L124">                try (InputStream inputStream = ResourceLoader.loadResourceAsStream(rulesetsProperties);) {</span>
<span class="nc" id="L125">                    props.load(inputStream);</span>
<span class="nc bnc" id="L126" title="All 8 branches missed.">                }</span>
<span class="nc" id="L127">                String rulesetFilenames = props.getProperty(&quot;rulesets.filenames&quot;);</span>
<span class="nc" id="L128">                ruleSetReferenceIds.addAll(RuleSetReferenceId.parse(rulesetFilenames));</span>
<span class="nc" id="L129">            }</span>
<span class="nc" id="L130">            return createRuleSets(ruleSetReferenceIds).getRuleSetsIterator();</span>
<span class="nc" id="L131">        } catch (IOException ioe) {</span>
<span class="nc" id="L132">            throw new RuntimeException(&quot;Couldn't find &quot; + rulesetsProperties</span>
                    + &quot;; please ensure that the rulesets directory is on the classpath.  The current classpath is: &quot;
                    + System.getProperty(&quot;java.class.path&quot;));
        }
    }

    /**
     * Create a RuleSets from a comma separated list of RuleSet reference IDs.
     * This is a convenience method which calls
     * {@link RuleSetReferenceId#parse(String)}, and then calls
     * {@link #createRuleSets(List)}. The currently configured ClassLoader is
     * used.
     *
     * @param referenceString
     *            A comma separated list of RuleSet reference IDs.
     * @return The new RuleSets.
     * @throws RuleSetNotFoundException
     *             if unable to find a resource.
     */
    public RuleSets createRuleSets(String referenceString) throws RuleSetNotFoundException {
<span class="fc" id="L152">        return createRuleSets(RuleSetReferenceId.parse(referenceString));</span>
    }

    /**
     * Create a RuleSets from a list of RuleSetReferenceIds. The currently
     * configured ClassLoader is used.
     *
     * @param ruleSetReferenceIds
     *            The List of RuleSetReferenceId of the RuleSets to create.
     * @return The new RuleSets.
     * @throws RuleSetNotFoundException
     *             if unable to find a resource.
     */
    public RuleSets createRuleSets(List&lt;RuleSetReferenceId&gt; ruleSetReferenceIds) throws RuleSetNotFoundException {
<span class="fc" id="L166">        RuleSets ruleSets = new RuleSets();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (RuleSetReferenceId ruleSetReferenceId : ruleSetReferenceIds) {</span>
<span class="fc" id="L168">            RuleSet ruleSet = createRuleSet(ruleSetReferenceId);</span>
<span class="fc" id="L169">            ruleSets.addRuleSet(ruleSet);</span>
<span class="fc" id="L170">        }</span>
<span class="fc" id="L171">        return ruleSets;</span>
    }

    /**
     * Create a RuleSet from a RuleSet reference ID string. This is a
     * convenience method which calls {@link RuleSetReferenceId#parse(String)},
     * gets the first item in the List, and then calls
     * {@link #createRuleSet(RuleSetReferenceId)}. The currently configured
     * ClassLoader is used.
     *
     * @param referenceString
     *            A comma separated list of RuleSet reference IDs.
     * @return A new RuleSet.
     * @throws RuleSetNotFoundException
     *             if unable to find a resource.
     */
    public RuleSet createRuleSet(String referenceString) throws RuleSetNotFoundException {
<span class="fc" id="L188">        List&lt;RuleSetReferenceId&gt; references = RuleSetReferenceId.parse(referenceString);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (references.isEmpty()) {</span>
<span class="nc" id="L190">            throw new RuleSetNotFoundException(</span>
                    &quot;No RuleSetReferenceId can be parsed from the string: &lt;&quot; + referenceString + &quot;&gt;&quot;);
        }
<span class="fc" id="L193">        return createRuleSet(references.get(0));</span>
    }

    /**
     * Create a RuleSet from a RuleSetReferenceId. Priority filtering is ignored
     * when loading a single Rule. The currently configured ClassLoader is used.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet to create.
     * @return A new RuleSet.
     * @throws RuleSetNotFoundException
     *             if unable to find a resource.
     */
    public RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId) throws RuleSetNotFoundException {
<span class="fc" id="L207">        return createRuleSet(ruleSetReferenceId, false);</span>
    }

    private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)
            throws RuleSetNotFoundException {
<span class="fc" id="L212">        return parseRuleSetNode(ruleSetReferenceId, withDeprecatedRuleReferences);</span>
    }

    /**
     * Creates a copy of the given ruleset. All properties like name, description, fileName
     * and exclude/include patterns are copied.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The rule instances are shared between the original
     * and the new ruleset (copy-by-reference). This might lead to concurrency issues,
     * if the original ruleset and the new ruleset are used in different threads.
     * &lt;/p&gt;
     *
     * @param original the original rule set to copy from
     * @return the copy
     */
    public RuleSet createRuleSetCopy(RuleSet original) {
<span class="nc" id="L228">        RuleSetBuilder builder = new RuleSetBuilder(original);</span>
<span class="nc" id="L229">        return builder.build();</span>
    }

    /**
     * Creates a new ruleset with the given metadata such as name, description,
     * fileName, exclude/include patterns are used. The rules are taken from the given
     * collection.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The rule instances are shared between the collection
     * and the new ruleset (copy-by-reference). This might lead to concurrency issues,
     * if the rules of the collection are also referenced by other rulesets and used
     * in different threads.
     * &lt;/p&gt;
     *
     * @param name the name of the ruleset
     * @param description the description
     * @param fileName the filename
     * @param excludePatterns list of exclude patterns
     * @param includePatterns list of include patterns
     * @param rules the collection with the rules to add to the new ruleset
     * @return the new ruleset
     */
    public RuleSet createNewRuleSet(String name, String description, String fileName, Collection&lt;String&gt; excludePatterns,
            Collection&lt;String&gt; includePatterns, Collection&lt;Rule&gt; rules) {
<span class="nc" id="L253">        RuleSetBuilder builder = new RuleSetBuilder(0L); // TODO: checksum missing</span>
<span class="nc" id="L254">        builder.withName(name)</span>
            .withDescription(description)
            .withFileName(fileName)
            .setExcludePatterns(excludePatterns)
            .setIncludePatterns(includePatterns);
<span class="nc bnc" id="L259" title="All 2 branches missed.">        for (Rule rule : rules) {</span>
<span class="nc" id="L260">            builder.addRule(rule);</span>
<span class="nc" id="L261">        }</span>
<span class="nc" id="L262">        return builder.build();</span>
    }

    /**
     * Creates a new RuleSet for a single rule
     * 
     * @param rule
     *            The rule being created
     * @return The newly created RuleSet
     */
    public RuleSet createSingleRuleRuleSet(final Rule rule) {
        final long checksum;
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (rule instanceof XPathRule) {</span>
<span class="nc" id="L275">            checksum = rule.getProperty(XPathRule.XPATH_DESCRIPTOR).hashCode();</span>
        } else {
            // TODO : Is this good enough? all properties' values + rule name
<span class="fc" id="L278">            checksum = rule.getPropertiesByPropertyDescriptor().values().hashCode() * 31 + rule.getName().hashCode();</span>
        }

<span class="fc" id="L281">        final RuleSetBuilder builder = new RuleSetBuilder(checksum)</span>
                .withName(rule.getName())
                .withDescription(&quot;RuleSet for &quot; + rule.getName());
<span class="fc" id="L284">        builder.addRule(rule);</span>
<span class="fc" id="L285">        return builder.build();</span>
    }

    /**
     * Create a Rule from a RuleSet created from a file name resource. The
     * currently configured ClassLoader is used.
     * &lt;p&gt;
     * Any Rules in the RuleSet other than the one being created, are _not_
     * created. Deprecated rules are _not_ ignored, so that they can be
     * referenced.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet with the Rule to create.
     * @param withDeprecatedRuleReferences
     *            Whether RuleReferences that are deprecated should be ignored
     *            or not
     * @return A new Rule.
     * @throws RuleSetNotFoundException
     *             if unable to find a resource.
     */
    private Rule createRule(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)
            throws RuleSetNotFoundException {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (ruleSetReferenceId.isAllRules()) {</span>
<span class="nc" id="L308">            throw new IllegalArgumentException(</span>
                    &quot;Cannot parse a single Rule from an all Rule RuleSet reference: &lt;&quot; + ruleSetReferenceId + &quot;&gt;.&quot;);
        }
<span class="fc" id="L311">        RuleSet ruleSet = createRuleSet(ruleSetReferenceId, withDeprecatedRuleReferences);</span>
<span class="fc" id="L312">        return ruleSet.getRuleByName(ruleSetReferenceId.getRuleName());</span>
    }

    /**
     * Parse a ruleset node to construct a RuleSet.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet being parsed.
     * @param withDeprecatedRuleReferences
     *            whether rule references that are deprecated should be ignored
     *            or not
     * @return The new RuleSet.
     */
    private RuleSet parseRuleSetNode(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)
            throws RuleSetNotFoundException {
<span class="fc" id="L327">        try (CheckedInputStream inputStream = new CheckedInputStream(</span>
                ruleSetReferenceId.getInputStream(this.classLoader), new Adler32());) {
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (!ruleSetReferenceId.isExternal()) {</span>
<span class="nc" id="L330">                throw new IllegalArgumentException(</span>
                        &quot;Cannot parse a RuleSet from a non-external reference: &lt;&quot; + ruleSetReferenceId + &quot;&gt;.&quot;);
            }
<span class="fc" id="L333">            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();</span>
            InputSource inputSource;
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (compatibilityFilter != null) {</span>
<span class="fc" id="L336">                inputSource = new InputSource(compatibilityFilter.filterRuleSetFile(inputStream));</span>
            } else {
<span class="nc" id="L338">                inputSource = new InputSource(inputStream);</span>
            }
<span class="fc" id="L340">            Document document = builder.parse(inputSource);</span>
<span class="fc" id="L341">            Element ruleSetElement = document.getDocumentElement();</span>

<span class="fc" id="L343">            RuleSetBuilder ruleSetBuilder = new RuleSetBuilder(inputStream.getChecksum().getValue())</span>
                    .withFileName(ruleSetReferenceId.getRuleSetFileName());

<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (ruleSetElement.hasAttribute(&quot;name&quot;)) {</span>
<span class="fc" id="L347">                ruleSetBuilder.withName(ruleSetElement.getAttribute(&quot;name&quot;));</span>
            } else {
<span class="fc" id="L349">                LOG.warning(&quot;RuleSet name is missing. Future versions of PMD will require it.&quot;);</span>
<span class="fc" id="L350">                ruleSetBuilder.withName(&quot;Missing RuleSet Name&quot;);</span>
            }

<span class="fc" id="L353">            NodeList nodeList = ruleSetElement.getChildNodes();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
<span class="fc" id="L355">                Node node = nodeList.item(i);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L357">                    String nodeName = node.getNodeName();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">                    if (DESCRIPTION.equals(nodeName)) {</span>
<span class="fc" id="L359">                        ruleSetBuilder.withDescription(parseTextNode(node));</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                    } else if (&quot;include-pattern&quot;.equals(nodeName)) {</span>
<span class="fc" id="L361">                        ruleSetBuilder.addIncludePattern(parseTextNode(node));</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">                    } else if (&quot;exclude-pattern&quot;.equals(nodeName)) {</span>
<span class="fc" id="L363">                        ruleSetBuilder.addExcludePattern(parseTextNode(node));</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                    } else if (&quot;rule&quot;.equals(nodeName)) {</span>
<span class="fc" id="L365">                        parseRuleNode(ruleSetReferenceId, ruleSetBuilder, node, withDeprecatedRuleReferences);</span>
                    } else {
<span class="nc" id="L367">                        throw new IllegalArgumentException(UNEXPECTED_ELEMENT + node.getNodeName()</span>
                                + &quot;&gt; encountered as child of &lt;ruleset&gt; element.&quot;);
                    }
                }
            }

<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (!ruleSetBuilder.hasDescription()) {</span>
<span class="fc" id="L374">                LOG.warning(&quot;RuleSet description is missing. Future versions of PMD will require it.&quot;);</span>
<span class="fc" id="L375">                ruleSetBuilder.withDescription(&quot;Missing description&quot;);</span>
            }

<span class="fc" id="L378">            return ruleSetBuilder.build();</span>
<span class="pc bpc" id="L379" title="4 of 8 branches missed.">        } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L380">            return classNotFoundProblem(cnfe);</span>
<span class="nc" id="L381">        } catch (InstantiationException ie) {</span>
<span class="nc" id="L382">            return classNotFoundProblem(ie);</span>
<span class="nc" id="L383">        } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L384">            return classNotFoundProblem(iae);</span>
<span class="nc" id="L385">        } catch (ParserConfigurationException pce) {</span>
<span class="nc" id="L386">            return classNotFoundProblem(pce);</span>
<span class="nc" id="L387">        } catch (IOException ioe) {</span>
<span class="nc" id="L388">            return classNotFoundProblem(ioe);</span>
<span class="nc" id="L389">        } catch (SAXException se) {</span>
<span class="nc" id="L390">            return classNotFoundProblem(se);</span>
        }
    }

    private static RuleSet classNotFoundProblem(Exception ex) {
<span class="nc" id="L395">        ex.printStackTrace();</span>
<span class="nc" id="L396">        throw new RuntimeException(&quot;Couldn't find the class &quot; + ex.getMessage());</span>
    }

    /**
     * Parse a rule node.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet being parsed.
     * @param ruleSetBuilder
     *            The RuleSet being constructed.
     * @param ruleNode
     *            Must be a rule element node.
     * @param withDeprecatedRuleReferences
     *            whether rule references that are deprecated should be ignored
     *            or not
     */
    private void parseRuleNode(RuleSetReferenceId ruleSetReferenceId, RuleSetBuilder ruleSetBuilder, Node ruleNode,
            boolean withDeprecatedRuleReferences)
            throws ClassNotFoundException, InstantiationException, IllegalAccessException, RuleSetNotFoundException {
<span class="fc" id="L415">        Element ruleElement = (Element) ruleNode;</span>
<span class="fc" id="L416">        String ref = ruleElement.getAttribute(&quot;ref&quot;);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (ref.endsWith(&quot;xml&quot;)) {</span>
<span class="fc" id="L418">            parseRuleSetReferenceNode(ruleSetReferenceId, ruleSetBuilder, ruleElement, ref);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        } else if (StringUtil.isEmpty(ref)) {</span>
<span class="fc" id="L420">            parseSingleRuleNode(ruleSetReferenceId, ruleSetBuilder, ruleNode);</span>
        } else {
<span class="fc" id="L422">            parseRuleReferenceNode(ruleSetReferenceId, ruleSetBuilder, ruleNode, ref, withDeprecatedRuleReferences);</span>
        }
<span class="fc" id="L424">    }</span>

    /**
     * Parse a rule node as an RuleSetReference for all Rules. Every Rule from
     * the referred to RuleSet will be added as a RuleReference except for those
     * explicitly excluded, below the minimum priority threshold for this
     * RuleSetFactory, or which are deprecated.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet being parsed.
     * @param ruleSetBuilder
     *            The RuleSet being constructed.
     * @param ruleElement
     *            Must be a rule element node.
     * @param ref
     *            The RuleSet reference.
     */
    private void parseRuleSetReferenceNode(RuleSetReferenceId ruleSetReferenceId, RuleSetBuilder ruleSetBuilder,
            Element ruleElement, String ref) throws RuleSetNotFoundException {
<span class="fc" id="L443">        RuleSetReference ruleSetReference = new RuleSetReference();</span>
<span class="fc" id="L444">        ruleSetReference.setAllRules(true);</span>
<span class="fc" id="L445">        ruleSetReference.setRuleSetFileName(ref);</span>
<span class="fc" id="L446">        String priority = null;</span>
<span class="fc" id="L447">        NodeList childNodes = ruleElement.getChildNodes();</span>
<span class="fc" id="L448">        Set&lt;String&gt; excludedRulesCheck = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (int i = 0; i &lt; childNodes.getLength(); i++) {</span>
<span class="fc" id="L450">            Node child = childNodes.item(i);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if (isElementNode(child, &quot;exclude&quot;)) {</span>
<span class="fc" id="L452">                Element excludeElement = (Element) child;</span>
<span class="fc" id="L453">                String excludedRuleName = excludeElement.getAttribute(&quot;name&quot;);</span>
<span class="fc" id="L454">                ruleSetReference.addExclude(excludedRuleName);</span>
<span class="fc" id="L455">                excludedRulesCheck.add(excludedRuleName);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            } else if (isElementNode(child, PRIORITY)) {</span>
<span class="fc" id="L457">                priority = parseTextNode(child).trim();</span>
            }
        }

<span class="fc" id="L461">        RuleSetFactory ruleSetFactory = new RuleSetFactory(this, warnDeprecated);</span>
<span class="fc" id="L462">        RuleSet otherRuleSet = ruleSetFactory.createRuleSet(RuleSetReferenceId.parse(ref).get(0));</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        for (Rule rule : otherRuleSet.getRules()) {</span>
<span class="fc" id="L464">            excludedRulesCheck.remove(rule.getName());</span>
<span class="fc bfc" id="L465" title="All 4 branches covered.">            if (!ruleSetReference.getExcludes().contains(rule.getName()) &amp;&amp; !rule.isDeprecated()) {</span>
<span class="fc" id="L466">                RuleReference ruleReference = new RuleReference();</span>
<span class="fc" id="L467">                ruleReference.setRuleSetReference(ruleSetReference);</span>
<span class="fc" id="L468">                ruleReference.setRule(rule);</span>
<span class="fc" id="L469">                ruleSetBuilder.addRuleIfNotExists(ruleReference);</span>

                // override the priority
<span class="fc bfc" id="L472" title="All 2 branches covered.">                if (priority != null) {</span>
<span class="fc" id="L473">                    ruleReference.setPriority(RulePriority.valueOf(Integer.parseInt(priority)));</span>
                }
            }
<span class="fc" id="L476">        }</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (!excludedRulesCheck.isEmpty()) {</span>
<span class="fc" id="L478">            throw new IllegalArgumentException(</span>
                    &quot;Unable to exclude rules &quot; + excludedRulesCheck + &quot;; perhaps the rule name is mispelled?&quot;);
        }
<span class="fc" id="L481">    }</span>

    /**
     * Parse a rule node as a single Rule. The Rule has been fully defined
     * within the context of the current RuleSet.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet being parsed.
     * @param ruleSet
     *            The RuleSet being constructed.
     * @param ruleNode
     *            Must be a rule element node.
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet being parsed.
     * @param ruleSetBuilder
     *            The RuleSet being constructed.
     * @param ruleNode
     *            Must be a rule element node.
     */
    private void parseSingleRuleNode(RuleSetReferenceId ruleSetReferenceId, RuleSetBuilder ruleSetBuilder,
            Node ruleNode) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
<span class="fc" id="L502">        Element ruleElement = (Element) ruleNode;</span>

        // Stop if we're looking for a particular Rule, and this element is not
        // it.
<span class="fc bfc" id="L506" title="All 4 branches covered.">        if (StringUtil.isNotEmpty(ruleSetReferenceId.getRuleName())</span>
                &amp;&amp; !isRuleName(ruleElement, ruleSetReferenceId.getRuleName())) {
<span class="fc" id="L508">            return;</span>
        }

<span class="fc" id="L511">        String attribute = ruleElement.getAttribute(&quot;class&quot;);</span>
<span class="pc bpc" id="L512" title="2 of 4 branches missed.">        if (attribute == null || &quot;&quot;.equals(attribute)) {</span>
<span class="nc" id="L513">            throw new IllegalArgumentException(&quot;The 'class' field of rule can't be null, nor empty.&quot;);</span>
        }
<span class="fc" id="L515">        Rule rule = (Rule) classLoader.loadClass(attribute).newInstance();</span>
<span class="fc" id="L516">        rule.setName(ruleElement.getAttribute(&quot;name&quot;));</span>

<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (ruleElement.hasAttribute(&quot;language&quot;)) {</span>
<span class="fc" id="L519">            String languageName = ruleElement.getAttribute(&quot;language&quot;);</span>
<span class="fc" id="L520">            Language language = LanguageRegistry.findLanguageByTerseName(languageName);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (language == null) {</span>
<span class="fc" id="L522">                throw new IllegalArgumentException(&quot;Unknown Language '&quot; + languageName + FOR_RULE + rule.getName()</span>
                        + &quot;, supported Languages are &quot;
                        + LanguageRegistry.commaSeparatedTerseNamesForLanguage(LanguageRegistry.findWithRuleSupport()));
            }
<span class="fc" id="L526">            rule.setLanguage(language);</span>
        }

<span class="fc" id="L529">        Language language = rule.getLanguage();</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        if (language == null) {</span>
<span class="nc" id="L531">            throw new IllegalArgumentException(</span>
                    &quot;Rule &quot; + rule.getName() + &quot; does not have a Language; missing 'language' attribute?&quot;);
        }

<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (ruleElement.hasAttribute(&quot;minimumLanguageVersion&quot;)) {</span>
<span class="fc" id="L536">            String minimumLanguageVersionName = ruleElement.getAttribute(&quot;minimumLanguageVersion&quot;);</span>
<span class="fc" id="L537">            LanguageVersion minimumLanguageVersion = language.getVersion(minimumLanguageVersionName);</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">            if (minimumLanguageVersion == null) {</span>
<span class="fc" id="L539">                throw new IllegalArgumentException(&quot;Unknown minimum Language Version '&quot; + minimumLanguageVersionName</span>
                        + &quot;' for Language '&quot; + language.getTerseName() + FOR_RULE + rule.getName()
                        + &quot;; supported Language Versions are: &quot;
                        + LanguageRegistry.commaSeparatedTerseNamesForLanguageVersion(language.getVersions()));
            }
<span class="fc" id="L544">            rule.setMinimumLanguageVersion(minimumLanguageVersion);</span>
        }

<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (ruleElement.hasAttribute(&quot;maximumLanguageVersion&quot;)) {</span>
<span class="fc" id="L548">            String maximumLanguageVersionName = ruleElement.getAttribute(&quot;maximumLanguageVersion&quot;);</span>
<span class="fc" id="L549">            LanguageVersion maximumLanguageVersion = language.getVersion(maximumLanguageVersionName);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (maximumLanguageVersion == null) {</span>
<span class="fc" id="L551">                throw new IllegalArgumentException(&quot;Unknown maximum Language Version '&quot; + maximumLanguageVersionName</span>
                        + &quot;' for Language '&quot; + language.getTerseName() + FOR_RULE + rule.getName()
                        + &quot;; supported Language Versions are: &quot;
                        + LanguageRegistry.commaSeparatedTerseNamesForLanguageVersion(language.getVersions()));
            }
<span class="fc" id="L556">            rule.setMaximumLanguageVersion(maximumLanguageVersion);</span>
        }

<span class="fc bfc" id="L559" title="All 4 branches covered.">        if (rule.getMinimumLanguageVersion() != null &amp;&amp; rule.getMaximumLanguageVersion() != null) {</span>
<span class="fc" id="L560">            throw new IllegalArgumentException(</span>
                    &quot;The minimum Language Version '&quot; + rule.getMinimumLanguageVersion().getTerseName()
                            + &quot;' must be prior to the maximum Language Version '&quot;
                            + rule.getMaximumLanguageVersion().getTerseName() + FOR_RULE + rule.getName()
                            + &quot;; perhaps swap them around?&quot;);
        }

<span class="fc" id="L567">        String since = ruleElement.getAttribute(&quot;since&quot;);</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (StringUtil.isNotEmpty(since)) {</span>
<span class="fc" id="L569">            rule.setSince(since);</span>
        }
<span class="fc" id="L571">        rule.setMessage(ruleElement.getAttribute(MESSAGE));</span>
<span class="fc" id="L572">        rule.setRuleSetName(ruleSetBuilder.getName());</span>
<span class="fc" id="L573">        rule.setExternalInfoUrl(ruleElement.getAttribute(EXTERNAL_INFO_URL));</span>

<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (hasAttributeSetTrue(ruleElement, &quot;dfa&quot;)) {</span>
<span class="fc" id="L576">            rule.setUsesDFA();</span>
        }

<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (hasAttributeSetTrue(ruleElement, &quot;typeResolution&quot;)) {</span>
<span class="nc" id="L580">            rule.setUsesTypeResolution();</span>
        }

<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (hasAttributeSetTrue(ruleElement, &quot;metrics&quot;)) {</span>
<span class="nc" id="L584">            rule.setUsesMetrics();</span>
        }

<span class="fc" id="L587">        final NodeList nodeList = ruleElement.getChildNodes();</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
<span class="fc" id="L589">            Node node = nodeList.item(i);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (node.getNodeType() != Node.ELEMENT_NODE) {</span>
<span class="fc" id="L591">                continue;</span>
            }
<span class="fc" id="L593">            String nodeName = node.getNodeName();</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">            if (DESCRIPTION.equals(nodeName)) {</span>
<span class="fc" id="L595">                rule.setDescription(parseTextNode(node));</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            } else if (&quot;example&quot;.equals(nodeName)) {</span>
<span class="fc" id="L597">                rule.addExample(parseTextNode(node));</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">            } else if (PRIORITY.equals(nodeName)) {</span>
<span class="fc" id="L599">                rule.setPriority(RulePriority.valueOf(Integer.parseInt(parseTextNode(node).trim())));</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            } else if (&quot;properties&quot;.equals(nodeName)) {</span>
<span class="fc" id="L601">                parsePropertiesNode(rule, node);</span>
            } else {
<span class="nc" id="L603">                throw new IllegalArgumentException(UNEXPECTED_ELEMENT + nodeName</span>
                        + &quot;&gt; encountered as child of &lt;rule&gt; element for Rule &quot; + rule.getName());
            }

        }
<span class="fc bfc" id="L608" title="All 4 branches covered.">        if (StringUtil.isNotEmpty(ruleSetReferenceId.getRuleName())</span>
                || rule.getPriority().compareTo(minimumPriority) &lt;= 0) {
<span class="fc" id="L610">            ruleSetBuilder.addRule(rule);</span>
        }
<span class="fc" id="L612">    }</span>

    private static boolean hasAttributeSetTrue(Element element, String attributeId) {
<span class="pc bpc" id="L615" title="1 of 4 branches missed.">        return element.hasAttribute(attributeId) &amp;&amp; &quot;true&quot;.equalsIgnoreCase(element.getAttribute(attributeId));</span>
    }

    /**
     * Parse a rule node as a RuleReference. A RuleReference is a single Rule
     * which comes from another RuleSet with some of it's attributes potentially
     * overridden.
     *
     * @param ruleSetReferenceId
     *            The RuleSetReferenceId of the RuleSet being parsed.
     * @param ruleSetBuilder
     *            The RuleSet being constructed.
     * @param ruleNode
     *            Must be a rule element node.
     * @param ref
     *            A reference to a Rule.
     * @param withDeprecatedRuleReferences
     *            whether rule references that are deprecated should be ignored
     *            or not
     */
    private void parseRuleReferenceNode(RuleSetReferenceId ruleSetReferenceId, RuleSetBuilder ruleSetBuilder,
            Node ruleNode, String ref, boolean withDeprecatedRuleReferences) throws RuleSetNotFoundException {
<span class="fc" id="L637">        Element ruleElement = (Element) ruleNode;</span>

        // Stop if we're looking for a particular Rule, and this element is not
        // it.
<span class="fc bfc" id="L641" title="All 4 branches covered.">        if (StringUtil.isNotEmpty(ruleSetReferenceId.getRuleName())</span>
                &amp;&amp; !isRuleName(ruleElement, ruleSetReferenceId.getRuleName())) {
<span class="fc" id="L643">            return;</span>
        }

<span class="fc" id="L646">        RuleSetFactory ruleSetFactory = new RuleSetFactory(this, warnDeprecated);</span>

<span class="fc" id="L648">        boolean isSameRuleSet = false;</span>
<span class="fc" id="L649">        RuleSetReferenceId otherRuleSetReferenceId = RuleSetReferenceId.parse(ref).get(0);</span>
<span class="fc bfc" id="L650" title="All 4 branches covered.">        if (!otherRuleSetReferenceId.isExternal()</span>
                &amp;&amp; containsRule(ruleSetReferenceId, otherRuleSetReferenceId.getRuleName())) {
<span class="fc" id="L652">            otherRuleSetReferenceId = new RuleSetReferenceId(ref, ruleSetReferenceId);</span>
<span class="fc" id="L653">            isSameRuleSet = true;</span>
        }
        // do not ignore deprecated rule references
<span class="fc" id="L656">        Rule referencedRule = ruleSetFactory.createRule(otherRuleSetReferenceId, true);</span>

<span class="fc bfc" id="L658" title="All 2 branches covered.">        if (referencedRule == null) {</span>
<span class="fc" id="L659">            throw new IllegalArgumentException(&quot;Unable to find referenced rule &quot; + otherRuleSetReferenceId.getRuleName()</span>
                    + &quot;; perhaps the rule name is mispelled?&quot;);
        }

<span class="pc bpc" id="L663" title="1 of 4 branches missed.">        if (warnDeprecated &amp;&amp; referencedRule.isDeprecated()) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (referencedRule instanceof RuleReference) {</span>
<span class="nc" id="L665">                RuleReference ruleReference = (RuleReference) referencedRule;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L667">                    LOG.warning(&quot;Use Rule name &quot; + ruleReference.getRuleSetReference().getRuleSetFileName() + &quot;/&quot;</span>
                            + ruleReference.getOriginalName() + &quot; instead of the deprecated Rule name &quot;
                            + otherRuleSetReferenceId
                            + &quot;. Future versions of PMD will remove support for this deprecated Rule name usage.&quot;);
                }
<span class="nc bnc" id="L672" title="All 2 branches missed.">            } else if (referencedRule instanceof MockRule) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L674">                    LOG.warning(&quot;Discontinue using Rule name &quot; + otherRuleSetReferenceId</span>
                            + &quot; as it has been removed from PMD and no longer functions.&quot;
                            + &quot; Future versions of PMD will remove support for this Rule.&quot;);
                }
            } else {
<span class="nc bnc" id="L679" title="All 2 branches missed.">                if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L680">                    LOG.warning(&quot;Discontinue using Rule name &quot; + otherRuleSetReferenceId</span>
                            + &quot; as it is scheduled for removal from PMD.&quot;
                            + &quot; Future versions of PMD will remove support for this Rule.&quot;);
                }
            }
        }

<span class="fc" id="L687">        RuleSetReference ruleSetReference = new RuleSetReference();</span>
<span class="fc" id="L688">        ruleSetReference.setAllRules(false);</span>
<span class="fc" id="L689">        ruleSetReference.setRuleSetFileName(otherRuleSetReferenceId.getRuleSetFileName());</span>

<span class="fc" id="L691">        RuleReference ruleReference = new RuleReference();</span>
<span class="fc" id="L692">        ruleReference.setRuleSetReference(ruleSetReference);</span>
<span class="fc" id="L693">        ruleReference.setRule(referencedRule);</span>

<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (ruleElement.hasAttribute(&quot;deprecated&quot;)) {</span>
<span class="fc" id="L696">            ruleReference.setDeprecated(Boolean.parseBoolean(ruleElement.getAttribute(&quot;deprecated&quot;)));</span>
        }
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (ruleElement.hasAttribute(&quot;name&quot;)) {</span>
<span class="fc" id="L699">            ruleReference.setName(ruleElement.getAttribute(&quot;name&quot;));</span>
        }
<span class="fc bfc" id="L701" title="All 2 branches covered.">        if (ruleElement.hasAttribute(MESSAGE)) {</span>
<span class="fc" id="L702">            ruleReference.setMessage(ruleElement.getAttribute(MESSAGE));</span>
        }
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        if (ruleElement.hasAttribute(EXTERNAL_INFO_URL)) {</span>
<span class="nc" id="L705">            ruleReference.setExternalInfoUrl(ruleElement.getAttribute(EXTERNAL_INFO_URL));</span>
        }
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (int i = 0; i &lt; ruleElement.getChildNodes().getLength(); i++) {</span>
<span class="fc" id="L708">            Node node = ruleElement.getChildNodes().item(i);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">                if (node.getNodeName().equals(DESCRIPTION)) {</span>
<span class="fc" id="L711">                    ruleReference.setDescription(parseTextNode(node));</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">                } else if (node.getNodeName().equals(&quot;example&quot;)) {</span>
<span class="fc" id="L713">                    ruleReference.addExample(parseTextNode(node));</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">                } else if (node.getNodeName().equals(PRIORITY)) {</span>
<span class="fc" id="L715">                    ruleReference.setPriority(RulePriority.valueOf(Integer.parseInt(parseTextNode(node))));</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">                } else if (node.getNodeName().equals(&quot;properties&quot;)) {</span>
<span class="fc" id="L717">                    parsePropertiesNode(ruleReference, node);</span>
                } else {
<span class="nc" id="L719">                    throw new IllegalArgumentException(UNEXPECTED_ELEMENT + node.getNodeName()</span>
                            + &quot;&gt; encountered as child of &lt;rule&gt; element for Rule &quot; + ruleReference.getName());
                }
            }
        }

<span class="fc bfc" id="L725" title="All 4 branches covered.">        if (StringUtil.isNotEmpty(ruleSetReferenceId.getRuleName())</span>
                || referencedRule.getPriority().compareTo(minimumPriority) &lt;= 0) {
<span class="fc bfc" id="L727" title="All 6 branches covered.">            if (withDeprecatedRuleReferences || !isSameRuleSet || !ruleReference.isDeprecated()) {</span>
<span class="fc" id="L728">                ruleSetBuilder.addRuleReplaceIfExists(ruleReference);</span>
            }
        }
<span class="fc" id="L731">    }</span>

    /**
     * Check whether the given ruleName is contained in the given ruleset.
     *
     * @param ruleSetReferenceId
     *            the ruleset to check
     * @param ruleName
     *            the rule name to search for
     * @return &lt;code&gt;true&lt;/code&gt; if the ruleName exists
     */
    private boolean containsRule(RuleSetReferenceId ruleSetReferenceId, String ruleName) {
<span class="fc" id="L743">        boolean found = false;</span>
<span class="pc" id="L744">        try (InputStream ruleSet = ruleSetReferenceId.getInputStream(classLoader)) {</span>
<span class="fc" id="L745">            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();</span>
<span class="fc" id="L746">            Document document = builder.parse(ruleSet);</span>
<span class="fc" id="L747">            Element ruleSetElement = document.getDocumentElement();</span>

<span class="fc" id="L749">            NodeList rules = ruleSetElement.getElementsByTagName(&quot;rule&quot;);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">            for (int i = 0; i &lt; rules.getLength(); i++) {</span>
<span class="fc" id="L751">                Element rule = (Element) rules.item(i);</span>
<span class="fc bfc" id="L752" title="All 4 branches covered.">                if (rule.hasAttribute(&quot;name&quot;) &amp;&amp; rule.getAttribute(&quot;name&quot;).equals(ruleName)) {</span>
<span class="fc" id="L753">                    found = true;</span>
<span class="fc" id="L754">                    break;</span>
                }
            }
<span class="pc bpc" id="L757" title="6 of 8 branches missed.">        } catch (Exception e) {</span>
<span class="nc" id="L758">            throw new RuntimeException(e);</span>
<span class="fc" id="L759">        }</span>

<span class="fc" id="L761">        return found;</span>
    }

    private static boolean isElementNode(Node node, String name) {
<span class="fc bfc" id="L765" title="All 4 branches covered.">        return node.getNodeType() == Node.ELEMENT_NODE &amp;&amp; node.getNodeName().equals(name);</span>
    }

    /**
     * Parse a properties node.
     *
     * @param rule
     *            The Rule to which the properties should be added.
     * @param propertiesNode
     *            Must be a properties element node.
     */
    private static void parsePropertiesNode(Rule rule, Node propertiesNode) {
<span class="fc bfc" id="L777" title="All 2 branches covered.">        for (int i = 0; i &lt; propertiesNode.getChildNodes().getLength(); i++) {</span>
<span class="fc" id="L778">            Node node = propertiesNode.getChildNodes().item(i);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            if (isElementNode(node, &quot;property&quot;)) {</span>
<span class="fc" id="L780">                parsePropertyNodeBR(rule, node);</span>
            }
        }
<span class="fc" id="L783">    }</span>

    private static String valueFrom(Node parentNode) {

<span class="fc" id="L787">        final NodeList nodeList = parentNode.getChildNodes();</span>

<span class="pc bpc" id="L789" title="1 of 2 branches missed.">        for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
<span class="fc" id="L790">            Node node = nodeList.item(i);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">            if (isElementNode(node, &quot;value&quot;)) {</span>
<span class="fc" id="L792">                return parseTextNode(node);</span>
            }
        }
<span class="nc" id="L795">        return null;</span>
    }

    /**
     * Parse a property node.
     *
     * @param rule
     *            The Rule to which the property should be added. //@param
     *            propertyNode Must be a property element node.
     */
    // private static void parsePropertyNode(Rule rule, Node propertyNode) {
    // Element propertyElement = (Element) propertyNode;
    // String name = propertyElement.getAttribute(&quot;name&quot;);
    // String description = propertyElement.getAttribute(&quot;description&quot;);
    // String type = propertyElement.getAttribute(&quot;type&quot;);
    // String delimiter = propertyElement.getAttribute(&quot;delimiter&quot;);
    // String min = propertyElement.getAttribute(&quot;min&quot;);
    // String max = propertyElement.getAttribute(&quot;max&quot;);
    // String value = propertyElement.getAttribute(&quot;value&quot;);
    //
    // // If value not provided, get from child &lt;value&gt; element.
    // if (StringUtil.isEmpty(value)) {
    // for (int i = 0; i &lt; propertyNode.getChildNodes().getLength(); i++) {
    // Node node = propertyNode.getChildNodes().item(i);
    // if ((node.getNodeType() == Node.ELEMENT_NODE) &amp;&amp;
    // node.getNodeName().equals(&quot;value&quot;)) {
    // value = parseTextNode(node);
    // }
    // }
    // }
    //
    // // Setting of existing property, or defining a new property?
    // if (StringUtil.isEmpty(type)) {
    // PropertyDescriptor propertyDescriptor = rule.getPropertyDescriptor(name);
    // if (propertyDescriptor == null) {
    // throw new IllegalArgumentException(&quot;Cannot set non-existant property '&quot; +
    // name + &quot;' on Rule &quot; + rule.getName());
    // } else {
    // Object realValue = propertyDescriptor.valueFrom(value);
    // rule.setProperty(propertyDescriptor, realValue);
    // }
    // } else {
    // PropertyDescriptor propertyDescriptor =
    // PropertyDescriptorFactory.createPropertyDescriptor(name, description,
    // type, delimiter, min, max, value);
    // rule.definePropertyDescriptor(propertyDescriptor);
    // }
    // }
    private static &lt;T&gt; void setValue(Rule rule, PropertyDescriptor&lt;T&gt; desc, String strValue) {
<span class="fc" id="L844">        T realValue = desc.valueFrom(strValue);</span>
<span class="fc" id="L845">        rule.setProperty(desc, realValue);</span>
<span class="fc" id="L846">    }</span>

    private static void parsePropertyNodeBR(Rule rule, Node propertyNode) {

<span class="fc" id="L850">        Element propertyElement = (Element) propertyNode;</span>
<span class="fc" id="L851">        String typeId = propertyElement.getAttribute(PropertyDescriptorFields.TYPE);</span>
<span class="fc" id="L852">        String strValue = propertyElement.getAttribute(PropertyDescriptorFields.VALUE);</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        if (StringUtil.isEmpty(strValue)) {</span>
<span class="fc" id="L854">            strValue = valueFrom(propertyElement);</span>
        }

        // Setting of existing property, or defining a new property?
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (StringUtil.isEmpty(typeId)) {</span>
<span class="fc" id="L859">            String name = propertyElement.getAttribute(PropertyDescriptorFields.NAME);</span>

<span class="fc" id="L861">            PropertyDescriptor&lt;?&gt; propertyDescriptor = rule.getPropertyDescriptor(name);</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">            if (propertyDescriptor == null) {</span>
<span class="nc" id="L863">                throw new IllegalArgumentException(</span>
                        &quot;Cannot set non-existant property '&quot; + name + &quot;' on Rule &quot; + rule.getName());
            } else {
<span class="fc" id="L866">                setValue(rule, propertyDescriptor, strValue);</span>
            }
<span class="fc" id="L868">            return;</span>
        }

<span class="fc" id="L871">        net.sourceforge.pmd.PropertyDescriptorFactory pdFactory = PropertyDescriptorUtil.factoryFor(typeId);</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (pdFactory == null) {</span>
<span class="nc" id="L873">            throw new RuntimeException(&quot;No property descriptor factory for type: &quot; + typeId);</span>
        }

<span class="fc" id="L876">        Map&lt;String, Boolean&gt; valueKeys = pdFactory.expectedFields();</span>
<span class="fc" id="L877">        Map&lt;String, String&gt; values = new HashMap&lt;&gt;(valueKeys.size());</span>

        // populate a map of values for an individual descriptor
<span class="fc bfc" id="L880" title="All 2 branches covered.">        for (Map.Entry&lt;String, Boolean&gt; entry : valueKeys.entrySet()) {</span>
<span class="fc" id="L881">            String valueStr = propertyElement.getAttribute(entry.getKey());</span>
<span class="fc bfc" id="L882" title="All 4 branches covered.">            if (entry.getValue() &amp;&amp; StringUtil.isEmpty(valueStr)) {</span>
                // TODO debug pt
<span class="fc" id="L884">                System.out.println(&quot;Missing required value for: &quot; + entry.getKey());</span>
            }
<span class="fc" id="L886">            values.put(entry.getKey(), valueStr);</span>
<span class="fc" id="L887">        }</span>

<span class="fc" id="L889">        PropertyDescriptor&lt;?&gt; desc = pdFactory.createWith(values);</span>
<span class="fc" id="L890">        PropertyDescriptorWrapper&lt;?&gt; wrapper = new PropertyDescriptorWrapper&lt;&gt;(desc);</span>

<span class="fc" id="L892">        rule.definePropertyDescriptor(wrapper);</span>
<span class="fc" id="L893">        setValue(rule, desc, strValue);</span>
<span class="fc" id="L894">    }</span>

    /**
     * Parse a String from a textually type node.
     *
     * @param node
     *            The node.
     * @return The String.
     */
    private static String parseTextNode(Node node) {

<span class="fc" id="L905">        final int nodeCount = node.getChildNodes().getLength();</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">        if (nodeCount == 0) {</span>
<span class="fc" id="L907">            return &quot;&quot;;</span>
        }

<span class="fc" id="L910">        StringBuilder buffer = new StringBuilder();</span>

<span class="fc bfc" id="L912" title="All 2 branches covered.">        for (int i = 0; i &lt; nodeCount; i++) {</span>
<span class="fc" id="L913">            Node childNode = node.getChildNodes().item(i);</span>
<span class="pc bpc" id="L914" title="1 of 4 branches missed.">            if (childNode.getNodeType() == Node.CDATA_SECTION_NODE || childNode.getNodeType() == Node.TEXT_NODE) {</span>
<span class="fc" id="L915">                buffer.append(childNode.getNodeValue());</span>
            }
        }
<span class="fc" id="L918">        return buffer.toString();</span>
    }

    /**
     * Determine if the specified rule element will represent a Rule with the
     * given name.
     *
     * @param ruleElement
     *            The rule element.
     * @param ruleName
     *            The Rule name.
     * @return &lt;code&gt;true&lt;/code&gt; if the Rule would have the given name,
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    private boolean isRuleName(Element ruleElement, String ruleName) {
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">        if (ruleElement.hasAttribute(&quot;name&quot;)) {</span>
<span class="fc" id="L934">            return ruleElement.getAttribute(&quot;name&quot;).equals(ruleName);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        } else if (ruleElement.hasAttribute(&quot;ref&quot;)) {</span>
<span class="nc" id="L936">            RuleSetReferenceId ruleSetReferenceId = RuleSetReferenceId.parse(ruleElement.getAttribute(&quot;ref&quot;)).get(0);</span>
<span class="nc bnc" id="L937" title="All 4 branches missed.">            return ruleSetReferenceId.getRuleName() != null &amp;&amp; ruleSetReferenceId.getRuleName().equals(ruleName);</span>
        } else {
<span class="nc" id="L939">            return false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>