<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassTypeResolver.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Java</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.java.typeresolution</a> &gt; <span class="el_source">ClassTypeResolver.java</span></div><h1>ClassTypeResolver.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.java.typeresolution;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import net.sourceforge.pmd.lang.ast.AbstractNode;
import net.sourceforge.pmd.lang.ast.Node;
import net.sourceforge.pmd.lang.java.ast.ASTAdditiveExpression;
import net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;
import net.sourceforge.pmd.lang.java.ast.ASTAndExpression;
import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimsAndInits;
import net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;
import net.sourceforge.pmd.lang.java.ast.ASTCastExpression;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;
import net.sourceforge.pmd.lang.java.ast.ASTConditionalAndExpression;
import net.sourceforge.pmd.lang.java.ast.ASTConditionalExpression;
import net.sourceforge.pmd.lang.java.ast.ASTConditionalOrExpression;
import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;
import net.sourceforge.pmd.lang.java.ast.ASTExclusiveOrExpression;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTInclusiveOrExpression;
import net.sourceforge.pmd.lang.java.ast.ASTInstanceOfExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;
import net.sourceforge.pmd.lang.java.ast.ASTMultiplicativeExpression;
import net.sourceforge.pmd.lang.java.ast.ASTName;
import net.sourceforge.pmd.lang.java.ast.ASTNormalAnnotation;
import net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;
import net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTPostfixExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPreDecrementExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPreIncrementExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;
import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;
import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;
import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;
import net.sourceforge.pmd.lang.java.ast.ASTReferenceType;
import net.sourceforge.pmd.lang.java.ast.ASTRelationalExpression;
import net.sourceforge.pmd.lang.java.ast.ASTShiftExpression;
import net.sourceforge.pmd.lang.java.ast.ASTSingleMemberAnnotation;
import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression;
import net.sourceforge.pmd.lang.java.ast.ASTUnaryExpressionNotPlusMinus;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;
import net.sourceforge.pmd.lang.java.ast.TypeNode;

//
// Helpful reading:
// http://www.janeg.ca/scjp/oper/promotions.html
// http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html
//

public class ClassTypeResolver extends JavaParserVisitorAdapter {

<span class="fc" id="L75">    private static final Logger LOG = Logger.getLogger(ClassTypeResolver.class.getName());</span>

    private static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVE_TYPES;
    private static final Map&lt;String, String&gt; JAVA_LANG;

    static {
        // Note: Assumption here that primitives come from same parent
        // ClassLoader regardless of what ClassLoader we are passed
<span class="fc" id="L83">        Map&lt;String, Class&lt;?&gt;&gt; thePrimitiveTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L84">        thePrimitiveTypes.put(&quot;void&quot;, Void.TYPE);</span>
<span class="fc" id="L85">        thePrimitiveTypes.put(&quot;boolean&quot;, Boolean.TYPE);</span>
<span class="fc" id="L86">        thePrimitiveTypes.put(&quot;byte&quot;, Byte.TYPE);</span>
<span class="fc" id="L87">        thePrimitiveTypes.put(&quot;char&quot;, Character.TYPE);</span>
<span class="fc" id="L88">        thePrimitiveTypes.put(&quot;short&quot;, Short.TYPE);</span>
<span class="fc" id="L89">        thePrimitiveTypes.put(&quot;int&quot;, Integer.TYPE);</span>
<span class="fc" id="L90">        thePrimitiveTypes.put(&quot;long&quot;, Long.TYPE);</span>
<span class="fc" id="L91">        thePrimitiveTypes.put(&quot;float&quot;, Float.TYPE);</span>
<span class="fc" id="L92">        thePrimitiveTypes.put(&quot;double&quot;, Double.TYPE);</span>
<span class="fc" id="L93">        PRIMITIVE_TYPES = Collections.unmodifiableMap(thePrimitiveTypes);</span>

<span class="fc" id="L95">        Map&lt;String, String&gt; theJavaLang = new HashMap&lt;&gt;();</span>
<span class="fc" id="L96">        theJavaLang.put(&quot;Boolean&quot;, &quot;java.lang.Boolean&quot;);</span>
<span class="fc" id="L97">        theJavaLang.put(&quot;Byte&quot;, &quot;java.lang.Byte&quot;);</span>
<span class="fc" id="L98">        theJavaLang.put(&quot;Character&quot;, &quot;java.lang.Character&quot;);</span>
<span class="fc" id="L99">        theJavaLang.put(&quot;CharSequence&quot;, &quot;java.lang.CharSequence&quot;);</span>
<span class="fc" id="L100">        theJavaLang.put(&quot;Class&quot;, &quot;java.lang.Class&quot;);</span>
<span class="fc" id="L101">        theJavaLang.put(&quot;ClassLoader&quot;, &quot;java.lang.ClassLoader&quot;);</span>
<span class="fc" id="L102">        theJavaLang.put(&quot;Cloneable&quot;, &quot;java.lang.Cloneable&quot;);</span>
<span class="fc" id="L103">        theJavaLang.put(&quot;Comparable&quot;, &quot;java.lang.Comparable&quot;);</span>
<span class="fc" id="L104">        theJavaLang.put(&quot;Compiler&quot;, &quot;java.lang.Compiler&quot;);</span>
<span class="fc" id="L105">        theJavaLang.put(&quot;Double&quot;, &quot;java.lang.Double&quot;);</span>
<span class="fc" id="L106">        theJavaLang.put(&quot;Float&quot;, &quot;java.lang.Float&quot;);</span>
<span class="fc" id="L107">        theJavaLang.put(&quot;InheritableThreadLocal&quot;, &quot;java.lang.InheritableThreadLocal&quot;);</span>
<span class="fc" id="L108">        theJavaLang.put(&quot;Integer&quot;, &quot;java.lang.Integer&quot;);</span>
<span class="fc" id="L109">        theJavaLang.put(&quot;Long&quot;, &quot;java.lang.Long&quot;);</span>
<span class="fc" id="L110">        theJavaLang.put(&quot;Math&quot;, &quot;java.lang.Math&quot;);</span>
<span class="fc" id="L111">        theJavaLang.put(&quot;Number&quot;, &quot;java.lang.Number&quot;);</span>
<span class="fc" id="L112">        theJavaLang.put(&quot;Object&quot;, &quot;java.lang.Object&quot;);</span>
<span class="fc" id="L113">        theJavaLang.put(&quot;Package&quot;, &quot;java.lang.Package&quot;);</span>
<span class="fc" id="L114">        theJavaLang.put(&quot;Process&quot;, &quot;java.lang.Process&quot;);</span>
<span class="fc" id="L115">        theJavaLang.put(&quot;Runnable&quot;, &quot;java.lang.Runnable&quot;);</span>
<span class="fc" id="L116">        theJavaLang.put(&quot;Runtime&quot;, &quot;java.lang.Runtime&quot;);</span>
<span class="fc" id="L117">        theJavaLang.put(&quot;RuntimePermission&quot;, &quot;java.lang.RuntimePermission&quot;);</span>
<span class="fc" id="L118">        theJavaLang.put(&quot;SecurityManager&quot;, &quot;java.lang.SecurityManager&quot;);</span>
<span class="fc" id="L119">        theJavaLang.put(&quot;Short&quot;, &quot;java.lang.Short&quot;);</span>
<span class="fc" id="L120">        theJavaLang.put(&quot;StackTraceElement&quot;, &quot;java.lang.StackTraceElement&quot;);</span>
<span class="fc" id="L121">        theJavaLang.put(&quot;StrictMath&quot;, &quot;java.lang.StrictMath&quot;);</span>
<span class="fc" id="L122">        theJavaLang.put(&quot;String&quot;, &quot;java.lang.String&quot;);</span>
<span class="fc" id="L123">        theJavaLang.put(&quot;StringBuffer&quot;, &quot;java.lang.StringBuffer&quot;);</span>
<span class="fc" id="L124">        theJavaLang.put(&quot;System&quot;, &quot;java.lang.System&quot;);</span>
<span class="fc" id="L125">        theJavaLang.put(&quot;Thread&quot;, &quot;java.lang.Thread&quot;);</span>
<span class="fc" id="L126">        theJavaLang.put(&quot;ThreadGroup&quot;, &quot;java.lang.ThreadGroup&quot;);</span>
<span class="fc" id="L127">        theJavaLang.put(&quot;ThreadLocal&quot;, &quot;java.lang.ThreadLocal&quot;);</span>
<span class="fc" id="L128">        theJavaLang.put(&quot;Throwable&quot;, &quot;java.lang.Throwable&quot;);</span>
<span class="fc" id="L129">        theJavaLang.put(&quot;Void&quot;, &quot;java.lang.Void&quot;);</span>
<span class="fc" id="L130">        JAVA_LANG = Collections.unmodifiableMap(theJavaLang);</span>
<span class="fc" id="L131">    }</span>

    private final PMDASMClassLoader pmdClassLoader;
    private Map&lt;String, String&gt; importedClasses;
    private List&lt;String&gt; importedOnDemand;
<span class="fc" id="L136">    private int anonymousClassCounter = 0;</span>

    public ClassTypeResolver() {
<span class="fc" id="L139">        this(ClassTypeResolver.class.getClassLoader());</span>
<span class="fc" id="L140">    }</span>

<span class="fc" id="L142">    public ClassTypeResolver(ClassLoader classLoader) {</span>
<span class="fc" id="L143">        pmdClassLoader = PMDASMClassLoader.getInstance(classLoader);</span>
<span class="fc" id="L144">    }</span>

    // FUTURE ASTCompilationUnit should not be a TypeNode. Clean this up
    // accordingly.
    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
<span class="fc" id="L150">        String className = null;</span>
        try {
<span class="fc" id="L152">            importedOnDemand = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L153">            importedClasses = new HashMap&lt;&gt;();</span>
<span class="fc" id="L154">            className = getClassName(node);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (className != null) {</span>
<span class="fc" id="L156">                populateClassName(node, className);</span>
            }
<span class="fc" id="L158">        } catch (ClassNotFoundException e) {</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L160">                LOG.log(Level.FINE, &quot;Could not find class &quot; + className + &quot;, due to: &quot; + e);</span>
            }
<span class="nc" id="L162">        } catch (NoClassDefFoundError e) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L164">                LOG.log(Level.FINE, &quot;Could not find class &quot; + className + &quot;, due to: &quot; + e);</span>
            }
<span class="nc" id="L166">        } catch (LinkageError e) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L168">                LOG.log(Level.WARNING, &quot;Could not find class &quot; + className + &quot;, due to: &quot; + e);</span>
            }
        } finally {
<span class="pc" id="L171">            populateImports(node);</span>
<span class="pc" id="L172">        }</span>
<span class="fc" id="L173">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
<span class="fc" id="L178">        ASTName importedType = (ASTName) node.jjtGetChild(0);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (importedType.getType() != null) {</span>
<span class="nc" id="L180">            node.setType(importedType.getType());</span>
        } else {
<span class="fc" id="L182">            populateType(node, importedType.getImage());</span>
        }

<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (node.getType() != null) {</span>
<span class="fc" id="L186">            node.setPackage(node.getType().getPackage());</span>
        }
<span class="fc" id="L188">        return data;</span>
    }

    @Override
    public Object visit(ASTTypeDeclaration node, Object data) {
<span class="fc" id="L193">        super.visit(node, data);</span>
<span class="fc" id="L194">        rollupTypeUnary(node);</span>
<span class="fc" id="L195">        return data;</span>
    }

    @Override
    public Object visit(ASTClassOrInterfaceType node, Object data) {
<span class="fc" id="L200">        String typeName = node.getImage();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (node.jjtGetParent().hasDescendantOfType(ASTClassOrInterfaceBody.class)) {</span>
<span class="fc" id="L202">            anonymousClassCounter++;</span>
<span class="fc" id="L203">            AbstractNode parent = node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (parent == null) {</span>
<span class="fc" id="L205">                parent = node.getFirstParentOfType(ASTEnumDeclaration.class);</span>
            }
<span class="fc" id="L207">            typeName = parent.getImage() + &quot;$&quot; + anonymousClassCounter;</span>
        }
<span class="fc" id="L209">        populateType(node, typeName);</span>
<span class="fc" id="L210">        return data;</span>
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
<span class="fc" id="L215">        populateType(node, node.getImage());</span>
<span class="fc" id="L216">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTEnumDeclaration node, Object data) {
<span class="fc" id="L221">        populateType(node, node.getImage());</span>
<span class="fc" id="L222">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTAnnotationTypeDeclaration node, Object data) {
<span class="fc" id="L227">        populateType(node, node.getImage());</span>
<span class="fc" id="L228">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTName node, Object data) {
        /*
         * Only doing this for nodes where getNameDeclaration is null this means
         * it's not a named node, i.e. Static reference or Annotation Doing this
         * for memory - TODO: Investigate if there is a valid memory concern or
         * not
         */
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (node.getNameDeclaration() == null) {</span>
            // Skip these scenarios as there is no type to populate in these
            // cases:
            // 1) Parent is a PackageDeclaration, which is not a type
            // 2) Parent is a ImportDeclaration, this is handled elsewhere.
<span class="pc bpc" id="L244" title="1 of 4 branches missed.">            if (!(node.jjtGetParent() instanceof ASTPackageDeclaration</span>
                    || node.jjtGetParent() instanceof ASTImportDeclaration)) {
<span class="fc" id="L246">                String name = node.getImage();</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                if (name.indexOf('.') != -1) {</span>
<span class="fc" id="L248">                    name = name.substring(0, name.indexOf('.'));</span>
                }
<span class="fc" id="L250">                populateType(node, name);</span>
<span class="fc" id="L251">            }</span>
        } else {
            // Carry over the type from the declaration
<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (node.getNameDeclaration().getNode() instanceof TypeNode) {</span>
<span class="fc" id="L255">                node.setType(((TypeNode) node.getNameDeclaration().getNode()).getType());</span>
            }
        }
<span class="fc" id="L258">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
<span class="fc" id="L263">        super.visit(node, data);</span>
<span class="fc" id="L264">        rollupTypeUnary(node);</span>
<span class="fc" id="L265">        return data;</span>
    }

    @Override
    public Object visit(ASTVariableDeclarator node, Object data) {
<span class="fc" id="L270">        super.visit(node, data);</span>
<span class="fc" id="L271">        rollupTypeUnary(node);</span>
<span class="fc" id="L272">        return data;</span>
    }

    @Override
    public Object visit(ASTVariableDeclaratorId node, Object data) {
<span class="pc bpc" id="L277" title="2 of 4 branches missed.">        if (node == null || node.getNameDeclaration() == null) {</span>
<span class="nc" id="L278">            return super.visit(node, data);</span>
        }
<span class="fc" id="L280">        String name = node.getNameDeclaration().getTypeImage();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (name != null) {</span>
<span class="fc" id="L282">            populateType(node, name);</span>
        }
<span class="fc" id="L284">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTType node, Object data) {
<span class="fc" id="L289">        super.visit(node, data);</span>
<span class="fc" id="L290">        rollupTypeUnary(node);</span>
<span class="fc" id="L291">        return data;</span>
    }

    @Override
    public Object visit(ASTReferenceType node, Object data) {
<span class="fc" id="L296">        super.visit(node, data);</span>
<span class="fc" id="L297">        rollupTypeUnary(node);</span>
<span class="fc" id="L298">        return data;</span>
    }

    @Override
    public Object visit(ASTPrimitiveType node, Object data) {
<span class="fc" id="L303">        populateType(node, node.getImage());</span>
<span class="fc" id="L304">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTExpression node, Object data) {
<span class="fc" id="L309">        super.visit(node, data);</span>
<span class="fc" id="L310">        rollupTypeUnary(node);</span>
<span class="fc" id="L311">        return data;</span>
    }

    @Override
    public Object visit(ASTConditionalExpression node, Object data) {
<span class="fc" id="L316">        super.visit(node, data);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (node.isTernary()) {</span>
            // TODO Rules for Ternary are complex
        } else {
<span class="nc" id="L320">            rollupTypeUnary(node);</span>
        }
<span class="fc" id="L322">        return data;</span>
    }

    @Override
    public Object visit(ASTConditionalOrExpression node, Object data) {
<span class="fc" id="L327">        populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L328">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTConditionalAndExpression node, Object data) {
<span class="fc" id="L333">        populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L334">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTInclusiveOrExpression node, Object data) {
<span class="fc" id="L339">        super.visit(node, data);</span>
<span class="fc" id="L340">        rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L341">        return data;</span>
    }

    @Override
    public Object visit(ASTExclusiveOrExpression node, Object data) {
<span class="fc" id="L346">        super.visit(node, data);</span>
<span class="fc" id="L347">        rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L348">        return data;</span>
    }

    @Override
    public Object visit(ASTAndExpression node, Object data) {
<span class="fc" id="L353">        super.visit(node, data);</span>
<span class="fc" id="L354">        rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L355">        return data;</span>
    }

    @Override
    public Object visit(ASTEqualityExpression node, Object data) {
<span class="fc" id="L360">        populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L361">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTInstanceOfExpression node, Object data) {
<span class="fc" id="L366">        populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L367">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTRelationalExpression node, Object data) {
<span class="fc" id="L372">        populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L373">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTShiftExpression node, Object data) {
<span class="fc" id="L378">        super.visit(node, data);</span>
        // Unary promotion on LHS is type of a shift operation
<span class="fc" id="L380">        rollupTypeUnaryNumericPromotion(node);</span>
<span class="fc" id="L381">        return data;</span>
    }

    @Override
    public Object visit(ASTAdditiveExpression node, Object data) {
<span class="fc" id="L386">        super.visit(node, data);</span>
<span class="fc" id="L387">        rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L388">        return data;</span>
    }

    @Override
    public Object visit(ASTMultiplicativeExpression node, Object data) {
<span class="fc" id="L393">        super.visit(node, data);</span>
<span class="fc" id="L394">        rollupTypeBinaryNumericPromotion(node);</span>
<span class="fc" id="L395">        return data;</span>
    }

    @Override
    public Object visit(ASTUnaryExpression node, Object data) {
<span class="fc" id="L400">        super.visit(node, data);</span>
<span class="fc" id="L401">        rollupTypeUnaryNumericPromotion(node);</span>
<span class="fc" id="L402">        return data;</span>
    }

    @Override
    public Object visit(ASTPreIncrementExpression node, Object data) {
<span class="fc" id="L407">        super.visit(node, data);</span>
<span class="fc" id="L408">        rollupTypeUnary(node);</span>
<span class="fc" id="L409">        return data;</span>
    }

    @Override
    public Object visit(ASTPreDecrementExpression node, Object data) {
<span class="fc" id="L414">        super.visit(node, data);</span>
<span class="fc" id="L415">        rollupTypeUnary(node);</span>
<span class="fc" id="L416">        return data;</span>
    }

    @Override
    public Object visit(ASTUnaryExpressionNotPlusMinus node, Object data) {
<span class="fc" id="L421">        super.visit(node, data);</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (&quot;!&quot;.equals(node.getImage())) {</span>
<span class="fc" id="L423">            populateType(node, &quot;boolean&quot;);</span>
        } else {
<span class="fc" id="L425">            rollupTypeUnary(node);</span>
        }
<span class="fc" id="L427">        return data;</span>
    }

    @Override
    public Object visit(ASTPostfixExpression node, Object data) {
<span class="fc" id="L432">        super.visit(node, data);</span>
<span class="fc" id="L433">        rollupTypeUnary(node);</span>
<span class="fc" id="L434">        return data;</span>
    }

    @Override
    public Object visit(ASTCastExpression node, Object data) {
<span class="fc" id="L439">        super.visit(node, data);</span>
<span class="fc" id="L440">        rollupTypeUnary(node);</span>
<span class="fc" id="L441">        return data;</span>
    }

    @Override
    public Object visit(ASTPrimaryExpression node, Object data) {
<span class="fc" id="L446">        super.visit(node, data);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (node.jjtGetNumChildren() == 1) {</span>
<span class="fc" id="L448">            rollupTypeUnary(node);</span>
        } else {
            // TODO OMG, this is complicated. PrimaryExpression, PrimaryPrefix
            // and PrimarySuffix are all related.
        }
<span class="fc" id="L453">        return data;</span>
    }

    @Override
    public Object visit(ASTPrimaryPrefix node, Object data) {
<span class="fc" id="L458">        super.visit(node, data);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (node.getImage() == null) {</span>
<span class="fc" id="L460">            rollupTypeUnary(node);</span>
        } else {
            // TODO OMG, this is complicated. PrimaryExpression, PrimaryPrefix
            // and PrimarySuffix are all related.
        }
<span class="fc" id="L465">        return data;</span>
    }

    @Override
    public Object visit(ASTPrimarySuffix node, Object data) {
<span class="fc" id="L470">        super.visit(node, data);</span>
        // TODO OMG, this is complicated. PrimaryExpression, PrimaryPrefix and
        // PrimarySuffix are all related.
<span class="fc" id="L473">        return data;</span>
    }

    @Override
    public Object visit(ASTNullLiteral node, Object data) {
        // No explicit type
<span class="fc" id="L479">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTBooleanLiteral node, Object data) {
<span class="fc" id="L484">        populateType(node, &quot;boolean&quot;);</span>
<span class="fc" id="L485">        return super.visit(node, data);</span>
    }

    @Override
    public Object visit(ASTLiteral node, Object data) {
<span class="fc" id="L490">        super.visit(node, data);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (node.jjtGetNumChildren() != 0) {</span>
<span class="fc" id="L492">            rollupTypeUnary(node);</span>
        } else {
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (node.isIntLiteral()) {</span>
<span class="fc" id="L495">                populateType(node, &quot;int&quot;);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            } else if (node.isLongLiteral()) {</span>
<span class="fc" id="L497">                populateType(node, &quot;long&quot;);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            } else if (node.isFloatLiteral()) {</span>
<span class="fc" id="L499">                populateType(node, &quot;float&quot;);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            } else if (node.isDoubleLiteral()) {</span>
<span class="fc" id="L501">                populateType(node, &quot;double&quot;);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            } else if (node.isCharLiteral()) {</span>
<span class="fc" id="L503">                populateType(node, &quot;char&quot;);</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">            } else if (node.isStringLiteral()) {</span>
<span class="fc" id="L505">                populateType(node, &quot;java.lang.String&quot;);</span>
            } else {
<span class="nc" id="L507">                throw new IllegalStateException(&quot;PMD error, unknown literal type!&quot;);</span>
            }
        }
<span class="fc" id="L510">        return data;</span>
    }

    @Override
    public Object visit(ASTAllocationExpression node, Object data) {
<span class="fc" id="L515">        super.visit(node, data);</span>

<span class="pc bpc" id="L517" title="2 of 8 branches missed.">        if (node.jjtGetNumChildren() &gt;= 2 &amp;&amp; node.jjtGetChild(1) instanceof ASTArrayDimsAndInits</span>
                || node.jjtGetNumChildren() &gt;= 3 &amp;&amp; node.jjtGetChild(2) instanceof ASTArrayDimsAndInits) {
            //
            // Classes for Array types cannot be found directly using
            // reflection.
            // As far as I can tell you have to create an array instance of the
            // necessary
            // dimensionality, and then ask for the type from the instance. OMFG
            // that's ugly.
            //

            // TODO Need to create utility method to allow array type creation
            // which will use
            // caching to avoid repeated object creation.
            // TODO Modify Parser to tell us array dimensions count.
            // TODO Parser seems to do some work to handle arrays in certain
            // case already.
            // Examine those to figure out what's going on, make sure _all_
            // array scenarios
            // are ultimately covered. Appears to use a Dimensionable interface
            // to handle
            // only a part of the APIs (not bump), but is implemented several
            // times, so
            // look at refactoring to eliminate duplication. Dimensionable is
            // also used
            // on AccessNodes for some scenarios, need to account for that.
            // Might be
            // missing some TypeNode candidates we can add to the AST and have
            // to deal
            // with here (e.g. FormalParameter)? Plus some existing usages may
            // be
            // incorrect.
        } else {
<span class="fc" id="L550">            rollupTypeUnary(node);</span>
        }
<span class="fc" id="L552">        return data;</span>
    }

    @Override
    public Object visit(ASTStatementExpression node, Object data) {
<span class="fc" id="L557">        super.visit(node, data);</span>
<span class="fc" id="L558">        rollupTypeUnary(node);</span>
<span class="fc" id="L559">        return data;</span>
    }

    @Override
    public Object visit(ASTNormalAnnotation node, Object data) {
<span class="fc" id="L564">        super.visit(node, data);</span>
<span class="fc" id="L565">        rollupTypeUnary(node);</span>
<span class="fc" id="L566">        return data;</span>
    }

    @Override
    public Object visit(ASTMarkerAnnotation node, Object data) {
<span class="fc" id="L571">        super.visit(node, data);</span>
<span class="fc" id="L572">        rollupTypeUnary(node);</span>
<span class="fc" id="L573">        return data;</span>
    }

    @Override
    public Object visit(ASTSingleMemberAnnotation node, Object data) {
<span class="fc" id="L578">        super.visit(node, data);</span>
<span class="fc" id="L579">        rollupTypeUnary(node);</span>
<span class="fc" id="L580">        return data;</span>
    }

    // Roll up the type based on type of the first child node.
    private void rollupTypeUnary(TypeNode typeNode) {
<span class="fc" id="L585">        Node node = typeNode;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (node.jjtGetNumChildren() &gt;= 1) {</span>
<span class="fc" id="L587">            Node child = node.jjtGetChild(0);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">            if (child instanceof TypeNode) {</span>
<span class="fc" id="L589">                typeNode.setType(((TypeNode) child).getType());</span>
            }
        }
<span class="fc" id="L592">    }</span>

    // Roll up the type based on type of the first child node using Unary
    // Numeric Promotion per JLS 5.6.1
    private void rollupTypeUnaryNumericPromotion(TypeNode typeNode) {
<span class="fc" id="L597">        Node node = typeNode;</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        if (node.jjtGetNumChildren() &gt;= 1) {</span>
<span class="fc" id="L599">            Node child = node.jjtGetChild(0);</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (child instanceof TypeNode) {</span>
<span class="fc" id="L601">                Class&lt;?&gt; type = ((TypeNode) child).getType();</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                if (type != null) {</span>
<span class="fc bfc" id="L603" title="All 6 branches covered.">                    if (&quot;byte&quot;.equals(type.getName()) || &quot;short&quot;.equals(type.getName())</span>
                            || &quot;char&quot;.equals(type.getName())) {
<span class="fc" id="L605">                        populateType(typeNode, &quot;int&quot;);</span>
                    } else {
<span class="fc" id="L607">                        typeNode.setType(((TypeNode) child).getType());</span>
                    }
                }
            }
        }
<span class="fc" id="L612">    }</span>

    // Roll up the type based on type of the first and second child nodes using
    // Binary Numeric Promotion per JLS 5.6.2
    private void rollupTypeBinaryNumericPromotion(TypeNode typeNode) {
<span class="fc" id="L617">        Node node = typeNode;</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (node.jjtGetNumChildren() &gt;= 2) {</span>
<span class="fc" id="L619">            Node child1 = node.jjtGetChild(0);</span>
<span class="fc" id="L620">            Node child2 = node.jjtGetChild(1);</span>
<span class="pc bpc" id="L621" title="2 of 4 branches missed.">            if (child1 instanceof TypeNode &amp;&amp; child2 instanceof TypeNode) {</span>
<span class="fc" id="L622">                Class&lt;?&gt; type1 = ((TypeNode) child1).getType();</span>
<span class="fc" id="L623">                Class&lt;?&gt; type2 = ((TypeNode) child2).getType();</span>
<span class="fc bfc" id="L624" title="All 4 branches covered.">                if (type1 != null &amp;&amp; type2 != null) {</span>
                    // Yeah, String is not numeric, but easiest place to handle
                    // it, only affects ASTAdditiveExpression
<span class="fc bfc" id="L627" title="All 4 branches covered.">                    if (&quot;java.lang.String&quot;.equals(type1.getName()) || &quot;java.lang.String&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L628">                        populateType(typeNode, &quot;java.lang.String&quot;);</span>
<span class="pc bpc" id="L629" title="1 of 4 branches missed.">                    } else if (&quot;boolean&quot;.equals(type1.getName()) || &quot;boolean&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L630">                        populateType(typeNode, &quot;boolean&quot;);</span>
<span class="fc bfc" id="L631" title="All 4 branches covered.">                    } else if (&quot;double&quot;.equals(type1.getName()) || &quot;double&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L632">                        populateType(typeNode, &quot;double&quot;);</span>
<span class="fc bfc" id="L633" title="All 4 branches covered.">                    } else if (&quot;float&quot;.equals(type1.getName()) || &quot;float&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L634">                        populateType(typeNode, &quot;float&quot;);</span>
<span class="fc bfc" id="L635" title="All 4 branches covered.">                    } else if (&quot;long&quot;.equals(type1.getName()) || &quot;long&quot;.equals(type2.getName())) {</span>
<span class="fc" id="L636">                        populateType(typeNode, &quot;long&quot;);</span>
                    } else {
<span class="fc" id="L638">                        populateType(typeNode, &quot;int&quot;);</span>
                    }
<span class="fc bfc" id="L640" title="All 4 branches covered.">                } else if (type1 != null || type2 != null) {</span>
                    // If one side is known to be a String, then the result is a
                    // String
                    // Yeah, String is not numeric, but easiest place to handle
                    // it, only affects ASTAdditiveExpression
<span class="fc bfc" id="L645" title="All 8 branches covered.">                    if (type1 != null &amp;&amp; &quot;java.lang.String&quot;.equals(type1.getName())</span>
                            || type2 != null &amp;&amp; &quot;java.lang.String&quot;.equals(type2.getName())) {
<span class="fc" id="L647">                        populateType(typeNode, &quot;java.lang.String&quot;);</span>
                    }
                }
            }
        }
<span class="fc" id="L652">    }</span>

    private void populateType(TypeNode node, String className) {

<span class="fc" id="L656">        String qualifiedName = className;</span>
<span class="fc" id="L657">        Class&lt;?&gt; myType = PRIMITIVE_TYPES.get(className);</span>
<span class="pc bpc" id="L658" title="1 of 4 branches missed.">        if (myType == null &amp;&amp; importedClasses != null) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">            if (importedClasses.containsKey(className)) {</span>
<span class="fc" id="L660">                qualifiedName = importedClasses.get(className);</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">            } else if (importedClasses.containsValue(className)) {</span>
<span class="fc" id="L662">                qualifiedName = className;</span>
            }
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            if (qualifiedName != null) {</span>
                try {
                    /*
                     * TODO - the map right now contains just class names. if we
                     * use a map of classname/class then we don't have to hit
                     * the class loader for every type - much faster
                     */
<span class="fc" id="L671">                    myType = pmdClassLoader.loadClass(qualifiedName);</span>
<span class="fc" id="L672">                } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L673">                    myType = processOnDemand(qualifiedName);</span>
<span class="nc" id="L674">                } catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L675">                    myType = processOnDemand(qualifiedName);</span>
<span class="nc" id="L676">                } catch (LinkageError e) {</span>
<span class="nc" id="L677">                    myType = processOnDemand(qualifiedName);</span>
<span class="pc" id="L678">                }</span>
            }
        }
<span class="pc bpc" id="L681" title="1 of 6 branches missed.">        if (myType == null &amp;&amp; qualifiedName != null &amp;&amp; qualifiedName.contains(&quot;.&quot;)) {</span>
            // try if the last part defines a inner class
<span class="fc" id="L683">            String qualifiedNameInner = qualifiedName.substring(0, qualifiedName.lastIndexOf('.')) + &quot;$&quot;</span>
                    + qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1);
            try {
<span class="fc" id="L686">                myType = pmdClassLoader.loadClass(qualifiedNameInner);</span>
<span class="fc" id="L687">            } catch (Exception e) {</span>
                // ignored
<span class="fc" id="L689">            }</span>
        }
<span class="pc bpc" id="L691" title="1 of 6 branches missed.">        if (myType == null &amp;&amp; qualifiedName != null &amp;&amp; !qualifiedName.contains(&quot;.&quot;)) {</span>
            // try again with java.lang....
            try {
<span class="fc" id="L694">                myType = pmdClassLoader.loadClass(&quot;java.lang.&quot; + qualifiedName);</span>
<span class="fc" id="L695">            } catch (Exception e) {</span>
                // ignored
<span class="fc" id="L697">            }</span>
        }
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (myType != null) {</span>
<span class="fc" id="L700">            node.setType(myType);</span>
        }
<span class="fc" id="L702">    }</span>

    /**
     * Check whether the supplied class name exists.
     */
    public boolean classNameExists(String fullyQualifiedClassName) {
        try {
<span class="fc" id="L709">            pmdClassLoader.loadClass(fullyQualifiedClassName);</span>
<span class="fc" id="L710">            return true; // Class found</span>
<span class="fc" id="L711">        } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L712">            return false;</span>
<span class="nc" id="L713">        } catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L714">            return false;</span>
        }
    }

    public Class&lt;?&gt; loadClass(String fullyQualifiedClassName) {
        try {
<span class="fc" id="L720">            return pmdClassLoader.loadClass(fullyQualifiedClassName);</span>
<span class="nc" id="L721">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L722">            return null;</span>
        }
    }

    private Class&lt;?&gt; processOnDemand(String qualifiedName) {
<span class="fc bfc" id="L727" title="All 2 branches covered.">        for (String entry : importedOnDemand) {</span>
            try {
<span class="fc" id="L729">                return pmdClassLoader.loadClass(entry + &quot;.&quot; + qualifiedName);</span>
<span class="fc" id="L730">            } catch (Throwable e) {</span>
            }
<span class="fc" id="L732">        }</span>
<span class="fc" id="L733">        return null;</span>
    }

    private String getClassName(ASTCompilationUnit node) {
<span class="fc" id="L737">        ASTClassOrInterfaceDeclaration classDecl = node.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (classDecl == null) {</span>
            // Happens if this compilation unit only contains an enum
<span class="fc" id="L740">            return null;</span>
        }
<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (node.declarationsAreInDefaultPackage()) {</span>
<span class="fc" id="L743">            return classDecl.getImage();</span>
        }
<span class="fc" id="L745">        ASTPackageDeclaration pkgDecl = node.getPackageDeclaration();</span>
<span class="fc" id="L746">        importedOnDemand.add(pkgDecl.getPackageNameImage());</span>
<span class="fc" id="L747">        return pkgDecl.getPackageNameImage() + &quot;.&quot; + classDecl.getImage();</span>
    }

    /**
     * If the outer class wasn't found then we'll get in here
     *
     * @param node
     */
    private void populateImports(ASTCompilationUnit node) {
<span class="fc" id="L756">        List&lt;ASTImportDeclaration&gt; theImportDeclarations = node.findChildrenOfType(ASTImportDeclaration.class);</span>

<span class="fc" id="L758">        importedClasses.putAll(JAVA_LANG);</span>

        // go through the imports
<span class="fc bfc" id="L761" title="All 2 branches covered.">        for (ASTImportDeclaration anImportDeclaration : theImportDeclarations) {</span>
<span class="fc" id="L762">            String strPackage = anImportDeclaration.getPackageName();</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">            if (anImportDeclaration.isImportOnDemand()) {</span>
<span class="fc" id="L764">                importedOnDemand.add(strPackage);</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">            } else if (!anImportDeclaration.isImportOnDemand()) {</span>
<span class="fc" id="L766">                String strName = anImportDeclaration.getImportedName();</span>
<span class="fc" id="L767">                importedClasses.put(strName, strName);</span>
<span class="fc" id="L768">                importedClasses.put(strName.substring(strPackage.length() + 1), strName);</span>
            }
<span class="fc" id="L770">        }</span>
<span class="fc" id="L771">    }</span>

    private void populateClassName(ASTCompilationUnit node, String className) throws ClassNotFoundException {
<span class="fc" id="L774">        node.setType(pmdClassLoader.loadClass(className));</span>
<span class="fc" id="L775">        importedClasses.putAll(pmdClassLoader.getImportedClasses(className));</span>
<span class="fc" id="L776">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>