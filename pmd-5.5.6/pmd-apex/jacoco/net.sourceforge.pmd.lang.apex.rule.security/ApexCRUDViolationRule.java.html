<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ApexCRUDViolationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMD Apex</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.pmd.lang.apex.rule.security</a> &gt; <span class="el_source">ApexCRUDViolationRule.java</span></div><h1>ApexCRUDViolationRule.java</h1><pre class="source lang-java linenums">/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
package net.sourceforge.pmd.lang.apex.rule.security;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import apex.jorje.data.ast.Identifier;
import apex.jorje.data.ast.TypeRef;
import apex.jorje.data.ast.TypeRef.ClassTypeRef;
import net.sourceforge.pmd.lang.apex.ast.ASTAssignmentExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTDottedExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTField;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclarationStatements;
import net.sourceforge.pmd.lang.apex.ast.ASTIfElseBlockStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTMethod;
import net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTNewNameValueObjectExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTParameter;
import net.sourceforge.pmd.lang.apex.ast.ASTProperty;
import net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTReturnStatement;
import net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;
import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;
import net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;
import net.sourceforge.pmd.lang.apex.ast.AbstractApexNode;
import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;
import net.sourceforge.pmd.lang.ast.Node;

/**
 * Finding missed CRUD checks for SOQL and DML operations.
 * 
 * @author sergey.gorbaty
 *
 */
public class ApexCRUDViolationRule extends AbstractApexRule {
<span class="fc" id="L58">    private static final Pattern VOID_OR_STRING_PATTERN = Pattern.compile(&quot;^(string|void)$&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L59">    private static final Pattern SELECT_FROM_PATTERN = Pattern.compile(&quot;[\\S|\\s]+?FROM[\\s]+?(\\w+)&quot;,</span>
            Pattern.CASE_INSENSITIVE);

<span class="fc" id="L62">    private final HashMap&lt;String, String&gt; varToTypeMapping = new HashMap&lt;&gt;();</span>
<span class="fc" id="L63">    private final ListMultimap&lt;String, String&gt; typeToDMLOperationMapping = ArrayListMultimap.create();</span>
<span class="fc" id="L64">    private final HashMap&lt;String, String&gt; checkedTypeToDMLOperationViaESAPI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L65">    private final WeakHashMap&lt;String, ASTMethod&gt; classMethods = new WeakHashMap&lt;&gt;();</span>

    private static final String IS_CREATEABLE = &quot;isCreateable&quot;;
    private static final String IS_DELETABLE = &quot;isDeletable&quot;;
    private static final String IS_UPDATEABLE = &quot;isUpdateable&quot;;
    private static final String IS_MERGEABLE = &quot;isMergeable&quot;;
    private static final String IS_ACCESSIBLE = &quot;isAccessible&quot;;
    private static final String ANY = &quot;ANY&quot;;
    private static final String S_OBJECT_TYPE = &quot;sObjectType&quot;;
    private static final String GET_DESCRIBE = &quot;getDescribe&quot;;

    // ESAPI.accessController().isAuthorizedToView(Lead.sObject, fields)
<span class="fc" id="L77">    private static final String[] ESAPI_ISAUTHORIZED_TO_VIEW = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToView&quot;, };
<span class="fc" id="L79">    private static final String[] ESAPI_ISAUTHORIZED_TO_CREATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToCreate&quot;, };
<span class="fc" id="L81">    private static final String[] ESAPI_ISAUTHORIZED_TO_UPDATE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToUpdate&quot;, };
<span class="fc" id="L83">    private static final String[] ESAPI_ISAUTHORIZED_TO_DELETE = new String[] { &quot;ESAPI&quot;, &quot;accessController&quot;,</span>
        &quot;isAuthorizedToDelete&quot;, };

<span class="fc" id="L86">    private static final String[] RESERVED_KEYS_FLS = new String[] { &quot;Schema&quot;, S_OBJECT_TYPE, };</span>

<span class="fc" id="L88">    public ApexCRUDViolationRule() {</span>
<span class="fc" id="L89">        setProperty(CODECLIMATE_CATEGORIES, new String[] { &quot;Security&quot; });</span>
<span class="fc" id="L90">        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 100);</span>
<span class="fc" id="L91">        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);</span>
<span class="fc" id="L92">    }</span>

    @Override
    public Object visit(ASTUserClass node, Object data) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (ASTMethod n : node.findDescendantsOfType(ASTMethod.class)) {</span>
<span class="fc" id="L97">            StringBuilder sb = new StringBuilder().append(n.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L98">                    .append(n.getNode().getMethodInfo().getCanonicalName()).append(&quot;:&quot;)</span>
<span class="fc" id="L99">                    .append(n.getNode().getMethodInfo().getParameterTypes().size());</span>
<span class="fc" id="L100">            classMethods.put(sb.toString(), n);</span>
<span class="fc" id="L101">        }</span>

<span class="fc" id="L103">        node.childrenAccept(this, data);</span>
<span class="fc" id="L104">        return data;</span>
    }

    @Override
    public Object visit(ASTMethodCallExpression node, Object data) {
<span class="fc" id="L109">        collectCRUDMethodLevelChecks(node);</span>
<span class="fc" id="L110">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlInsertStatement node, Object data) {
<span class="fc" id="L115">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L116">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlDeleteStatement node, Object data) {
<span class="fc" id="L121">        checkForCRUD(node, data, IS_DELETABLE);</span>
<span class="fc" id="L122">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpdateStatement node, Object data) {
<span class="fc" id="L127">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L128">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlUpsertStatement node, Object data) {
<span class="fc" id="L133">        checkForCRUD(node, data, IS_CREATEABLE);</span>
<span class="fc" id="L134">        checkForCRUD(node, data, IS_UPDATEABLE);</span>
<span class="fc" id="L135">        return data;</span>
    }

    @Override
    public Object visit(ASTDmlMergeStatement node, Object data) {
<span class="nc" id="L140">        checkForCRUD(node, data, IS_MERGEABLE);</span>
<span class="nc" id="L141">        return data;</span>
    }

    @Override
    public Object visit(final ASTAssignmentExpression node, Object data) {
<span class="fc" id="L146">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L148">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L151">        return data;</span>
    }

    @Override
    public Object visit(final ASTVariableDeclaration node, Object data) {
<span class="fc" id="L156">        String type = node.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L157">        addVariableToMapping(Helper.getFQVariableName(node), type);</span>

<span class="fc" id="L159">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L161">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L164">        return data;</span>

    }

    @Override
    public Object visit(final ASTFieldDeclaration node, Object data) {
<span class="fc" id="L170">        ASTFieldDeclarationStatements field = node.getFirstParentOfType(ASTFieldDeclarationStatements.class);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (field != null) {</span>
            try {
<span class="fc" id="L173">                TypeRef a = field.getNode().getTypeName();</span>
<span class="fc" id="L174">                Field classNameField = a.getClass().getDeclaredField(&quot;className&quot;);</span>
<span class="fc" id="L175">                Field typeArgsField = a.getClass().getDeclaredField(&quot;typeArguments&quot;);</span>
<span class="fc" id="L176">                classNameField.setAccessible(true);</span>
<span class="fc" id="L177">                typeArgsField.setAccessible(true);</span>

<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                if (typeArgsField.get(a) instanceof Optional&lt;?&gt;) {</span>
<span class="fc" id="L180">                    Optional&lt;?&gt; optionalContainer = (Optional&lt;?&gt;) typeArgsField.get(a);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                    if (optionalContainer.isPresent()) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L183">                        ArrayList&lt;ClassTypeRef&gt; inner = (ArrayList&lt;ClassTypeRef&gt;) optionalContainer.get();</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">                        if (!inner.isEmpty()) {</span>
<span class="fc" id="L185">                            ClassTypeRef innerClassRef = inner.get(0);</span>
<span class="fc" id="L186">                            List&lt;Identifier&gt; ids = innerClassRef.className;</span>
<span class="fc" id="L187">                            String argType = ids.get(0).value;</span>
<span class="fc" id="L188">                            addVariableToMapping(Helper.getFQVariableName(node), argType);</span>
                        }
                    }
                }

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (classNameField.get(a) instanceof ArrayList&lt;?&gt;) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L195">                    ArrayList&lt;Identifier&gt; innerField = (ArrayList&lt;Identifier&gt;) classNameField.get(a);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">                    if (!innerField.isEmpty()) {</span>
<span class="fc" id="L197">                        String type = innerField.get(0).value;</span>
<span class="fc" id="L198">                        addVariableToMapping(Helper.getFQVariableName(node), type);</span>
                    }
                }

<span class="nc" id="L202">            } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException | SecurityException e) {</span>
<span class="fc" id="L203">            }</span>

        }
<span class="fc" id="L206">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (soql != null) {</span>
<span class="nc" id="L208">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L211">        return data;</span>

    }

    @Override
    public Object visit(final ASTReturnStatement node, Object data) {
<span class="fc" id="L217">        final ASTSoqlExpression soql = node.getFirstChildOfType(ASTSoqlExpression.class);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (soql != null) {</span>
<span class="fc" id="L219">            checkForAccessibility(soql, data);</span>
        }

<span class="fc" id="L222">        return data;</span>
    }

    private void addVariableToMapping(final String variableName, final String type) {
<span class="pc bpc" id="L226" title="4 of 9 branches missed.">        switch (type.toLowerCase()) {</span>
        case &quot;list&quot;:
        case &quot;map&quot;:
<span class="fc" id="L229">            return;</span>
        default:
<span class="fc" id="L231">            varToTypeMapping.put(variableName, getSimpleType(type));</span>
        }
<span class="fc" id="L233">    }</span>

    private String getSimpleType(final String type) {
<span class="fc" id="L236">        String typeToUse = type;</span>

<span class="fc" id="L238">        Pattern pattern = Pattern.compile(&quot;^[list&lt;]?list&lt;(\\S+?)&gt;[&gt;]?$&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L239">        Matcher matcher = pattern.matcher(typeToUse);</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (matcher.find()) {</span>
<span class="fc" id="L242">            typeToUse = matcher.group(1);</span>
        }
<span class="fc" id="L244">        return typeToUse;</span>
    }

    @Override
    public Object visit(final ASTProperty node, Object data) {
<span class="fc" id="L249">        ASTField field = node.getFirstChildOfType(ASTField.class);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (field != null) {</span>
<span class="fc" id="L251">            String fieldType = field.getNode().getFieldInfo().getType().getApexName();</span>
<span class="fc" id="L252">            addVariableToMapping(Helper.getFQVariableName(field), fieldType);</span>
        }

<span class="fc" id="L255">        return data;</span>

    }

    private void collectCRUDMethodLevelChecks(final ASTMethodCallExpression node) {
<span class="fc" id="L260">        final String method = node.getNode().getMethodName();</span>
<span class="fc" id="L261">        final ASTReferenceExpression ref = node.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (ref == null) {</span>
<span class="nc" id="L263">            return;</span>
        }

<span class="fc" id="L266">        List&lt;Identifier&gt; a = ref.getNode().getJadtIdentifiers();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (!a.isEmpty()) {</span>
<span class="fc" id="L268">            extractObjectAndFields(a, method, node.getNode().getDefiningType().getApexName());</span>
        } else {
            // see if ESAPI
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_VIEW)) {</span>
<span class="fc" id="L272">                extractObjectTypeFromESAPI(node, IS_ACCESSIBLE);</span>
            }

<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_CREATE)) {</span>
<span class="nc" id="L276">                extractObjectTypeFromESAPI(node, IS_CREATEABLE);</span>
            }

<span class="fc bfc" id="L279" title="All 2 branches covered.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_UPDATE)) {</span>
<span class="fc" id="L280">                extractObjectTypeFromESAPI(node, IS_UPDATEABLE);</span>
            }

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            if (Helper.isMethodCallChain(node, ESAPI_ISAUTHORIZED_TO_DELETE)) {</span>
<span class="nc" id="L284">                extractObjectTypeFromESAPI(node, IS_DELETABLE);</span>
            }

            // see if getDescribe()
<span class="fc" id="L288">            final ASTDottedExpression dottedExpr = ref.getFirstChildOfType(ASTDottedExpression.class);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            if (dottedExpr != null) {</span>
<span class="fc" id="L290">                final ASTMethodCallExpression nestedMethodCall = dottedExpr</span>
<span class="fc" id="L291">                        .getFirstChildOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">                if (nestedMethodCall != null) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">                    if (isLastMethodName(nestedMethodCall, S_OBJECT_TYPE, GET_DESCRIBE)) {</span>
<span class="fc" id="L294">                        String resolvedType = getType(nestedMethodCall);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                        if (!typeToDMLOperationMapping.get(resolvedType).contains(method)) {</span>
<span class="fc" id="L296">                            typeToDMLOperationMapping.put(resolvedType, method);</span>
                        }
                    }
                }
            }

        }
<span class="fc" id="L303">    }</span>

    private boolean isLastMethodName(final ASTMethodCallExpression methodNode, final String className,
            final String methodName) {
<span class="fc" id="L307">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L309">            if (reference.getNode().getJadtIdentifiers().get(reference.getNode().getJadtIdentifiers().size() - 1).value</span>
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">                    .equalsIgnoreCase(className) &amp;&amp; Helper.isMethodName(methodNode, methodName)) {</span>
<span class="fc" id="L311">                return true;</span>
            }
        }

<span class="fc" id="L315">        return false;</span>
    }

    private String getType(final ASTMethodCallExpression methodNode) {
<span class="fc" id="L319">        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (reference.getNode().getJadtIdentifiers().size() &gt; 0) {</span>
<span class="fc" id="L321">            return new StringBuilder().append(reference.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L322">                    .append(reference.getNode().getJadtIdentifiers().get(0).value).toString();</span>
        }
<span class="nc" id="L324">        return &quot;&quot;;</span>
    }

    private void extractObjectAndFields(final List&lt;Identifier&gt; listIdentifiers, final String method,
            final String definingType) {
<span class="fc" id="L329">        final List&lt;String&gt; strings = listIdentifiers.stream().map(id -&gt; id.value).collect(Collectors.toList());</span>

<span class="fc" id="L331">        int flsIndex = Collections.lastIndexOfSubList(strings, Arrays.asList(RESERVED_KEYS_FLS));</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (flsIndex != -1) {</span>
<span class="fc" id="L333">            String objectTypeName = strings.get(flsIndex + RESERVED_KEYS_FLS.length);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            if (!typeToDMLOperationMapping.get(definingType + &quot;:&quot; + objectTypeName).contains(method)) {</span>
<span class="fc" id="L335">                typeToDMLOperationMapping.put(definingType + &quot;:&quot; + objectTypeName, method);</span>
            }
        }
<span class="fc" id="L338">    }</span>

    private void checkForCRUD(final AbstractApexNode&lt;?&gt; node, final Object data, final String crudMethod) {
<span class="fc" id="L341">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L343">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L344">        }</span>

<span class="fc" id="L346">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L347">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L349" title="2 of 6 branches missed.">        if ((wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="fc" id="L351">            return;</span>
        }

<span class="fc" id="L354">        final ASTNewNameValueObjectExpression newObj = node.getFirstChildOfType(ASTNewNameValueObjectExpression.class);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (newObj != null) {</span>
<span class="fc" id="L356">            final String type = Helper.getFQVariableName(newObj);</span>
<span class="fc" id="L357">            validateCRUDCheckPresent(node, data, crudMethod, type);</span>
        }

<span class="fc" id="L360">        final ASTVariableExpression variable = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (variable != null) {</span>
<span class="fc" id="L362">            final String type = varToTypeMapping.get(Helper.getFQVariableName(variable));</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="fc" id="L364">                StringBuilder typeCheck = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L365">                        .append(&quot;:&quot;).append(type);</span>

<span class="fc" id="L367">                validateCRUDCheckPresent(node, data, crudMethod, typeCheck.toString());</span>
            }
        }
<span class="fc" id="L370">    }</span>

    private HashSet&lt;ASTMethodCallExpression&gt; getPreviousMethodCalls(final AbstractApexNode&lt;?&gt; self) {
<span class="fc" id="L373">        final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls = new HashSet&lt;&gt;();</span>
<span class="fc" id="L374">        final ASTMethod outerMethod = self.getFirstParentOfType(ASTMethod.class);</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (outerMethod != null) {</span>
<span class="fc" id="L376">            final ASTBlockStatement blockStatement = outerMethod.getFirstChildOfType(ASTBlockStatement.class);</span>
<span class="fc" id="L377">            recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, blockStatement);</span>

<span class="fc" id="L379">            final List&lt;ASTMethod&gt; constructorMethods = findConstructorlMethods(self);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            for (ASTMethod method : constructorMethods) {</span>
<span class="fc" id="L381">                innerMethodCalls.addAll(method.findDescendantsOfType(ASTMethodCallExpression.class));</span>
<span class="fc" id="L382">            }</span>

            // some methods might be within this class
<span class="fc" id="L385">            mapCallToMethodDecl(self, innerMethodCalls, new ArrayList&lt;ASTMethodCallExpression&gt;(innerMethodCalls));</span>
        }

<span class="fc" id="L388">        return innerMethodCalls;</span>
    }

    private void recursivelyEvaluateCRUDMethodCalls(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final ASTBlockStatement blockStatement) {
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (blockStatement != null) {</span>
<span class="fc" id="L394">            int numberOfStatements = blockStatement.jjtGetNumChildren();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfStatements; i++) {</span>
<span class="fc" id="L396">                Node n = blockStatement.jjtGetChild(i);</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">                if (n instanceof ASTIfElseBlockStatement) {</span>
<span class="fc" id="L399">                    List&lt;ASTBlockStatement&gt; innerBlocks = n.findDescendantsOfType(ASTBlockStatement.class);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                    for (ASTBlockStatement innerBlock : innerBlocks) {</span>
<span class="fc" id="L401">                        recursivelyEvaluateCRUDMethodCalls(self, innerMethodCalls, innerBlock);</span>
<span class="fc" id="L402">                    }</span>
                }

<span class="fc" id="L405">                AbstractApexNode&lt;?&gt; match = n.getFirstDescendantOfType(self.getClass());</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if (match == self) {</span>
<span class="fc" id="L407">                    break;</span>
                }
<span class="fc" id="L409">                ASTMethodCallExpression methodCall = n.getFirstDescendantOfType(ASTMethodCallExpression.class);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">                if (methodCall != null) {</span>
<span class="fc" id="L411">                    mapCallToMethodDecl(self, innerMethodCalls, Arrays.asList(methodCall));</span>
                }
            }

        }
<span class="fc" id="L416">    }</span>

    private void mapCallToMethodDecl(final AbstractApexNode&lt;?&gt; self,
            final HashSet&lt;ASTMethodCallExpression&gt; innerMethodCalls, final List&lt;ASTMethodCallExpression&gt; nodes) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (ASTMethodCallExpression node : nodes) {</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if (node == self) {</span>
<span class="nc" id="L422">                break;</span>
            }

<span class="fc" id="L425">            final ASTMethod methodBody = resolveMethodCalls(node);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (methodBody != null) {</span>
<span class="fc" id="L427">                innerMethodCalls.addAll(methodBody.findDescendantsOfType(ASTMethodCallExpression.class));</span>
            }

<span class="fc" id="L430">        }</span>
<span class="fc" id="L431">    }</span>

    private List&lt;ASTMethod&gt; findConstructorlMethods(final AbstractApexNode&lt;?&gt; node) {
<span class="fc" id="L434">        final ArrayList&lt;ASTMethod&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L435">        final Set&lt;String&gt; constructors = classMethods.keySet().stream()</span>
<span class="fc bfc" id="L436" title="All 4 branches covered.">                .filter(p -&gt; (p.contains(&quot;&lt;init&gt;&quot;) || p.contains(&quot;&lt;clinit&gt;&quot;))).collect(Collectors.toSet());</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (String c : constructors) {</span>
<span class="fc" id="L439">            ret.add(classMethods.get(c));</span>
<span class="fc" id="L440">        }</span>

<span class="fc" id="L442">        return ret;</span>
    }

    private ASTMethod resolveMethodCalls(final ASTMethodCallExpression node) {
<span class="fc" id="L446">        StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L447">                .append(node.getNode().getMethodName()).append(&quot;:&quot;).append(node.getNode().getInputParameters().size());</span>
<span class="fc" id="L448">        return classMethods.get(sb.toString());</span>
    }

    private boolean isProperESAPICheckForDML(final String typeToCheck, final String dmlOperation) {
<span class="fc" id="L452">        final boolean hasMapping = checkedTypeToDMLOperationViaESAPI.containsKey(typeToCheck.toString());</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (hasMapping) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (dmlOperation.equals(ANY)) {</span>
<span class="fc" id="L455">                return true;</span>
            }

<span class="fc" id="L458">            String dmlChecked = checkedTypeToDMLOperationViaESAPI.get(typeToCheck);</span>
<span class="fc" id="L459">            return dmlChecked.equals(dmlOperation);</span>
        }

<span class="fc" id="L462">        return false;</span>
    }

    private void extractObjectTypeFromESAPI(final ASTMethodCallExpression node, final String dmlOperation) {
<span class="fc" id="L466">        final ASTVariableExpression var = node.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (var != null) {</span>
<span class="fc" id="L468">            final ASTReferenceExpression reference = var.getFirstChildOfType(ASTReferenceExpression.class);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">            if (reference != null) {</span>
<span class="fc" id="L470">                List&lt;Identifier&gt; identifiers = reference.getNode().getJadtIdentifiers();</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">                if (identifiers.size() == 1) {</span>
<span class="fc" id="L472">                    StringBuilder sb = new StringBuilder().append(node.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L473">                            .append(&quot;:&quot;).append(identifiers.get(0).value);</span>
<span class="fc" id="L474">                    checkedTypeToDMLOperationViaESAPI.put(sb.toString(), dmlOperation);</span>
                }

            }
        }

<span class="fc" id="L480">    }</span>

    private void validateCRUDCheckPresent(final AbstractApexNode&lt;?&gt; node, final Object data, final String CRUDMethod,
            final String typeCheck) {
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (!typeToDMLOperationMapping.containsKey(typeCheck)) {</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (!isProperESAPICheckForDML(typeCheck, CRUDMethod)) {</span>
<span class="fc" id="L486">                addViolation(data, node);</span>
            }
        } else {
<span class="fc" id="L489">            boolean properChecksHappened = false;</span>

<span class="fc" id="L491">            List&lt;String&gt; dmlOperationsChecked = typeToDMLOperationMapping.get(typeCheck);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">            for (String dmlOp : dmlOperationsChecked) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">                if (dmlOp.equalsIgnoreCase(CRUDMethod)) {</span>
<span class="fc" id="L494">                    properChecksHappened = true;</span>
<span class="fc" id="L495">                    break;</span>
                }
<span class="fc bfc" id="L497" title="All 2 branches covered.">                if (CRUDMethod.equals(ANY)) {</span>
<span class="fc" id="L498">                    properChecksHappened = true;</span>
<span class="fc" id="L499">                    break;</span>
                }
<span class="fc" id="L501">            }</span>

<span class="fc bfc" id="L503" title="All 2 branches covered.">            if (!properChecksHappened) {</span>
<span class="fc" id="L504">                addViolation(data, node);</span>
            }
        }
<span class="fc" id="L507">    }</span>

    private void checkForAccessibility(final ASTSoqlExpression node, Object data) {
<span class="fc" id="L510">        final boolean isCount = node.getNode().getCanonicalQuery().startsWith(&quot;SELECT COUNT()&quot;);</span>
<span class="fc" id="L511">        final Set&lt;String&gt; typesFromSOQL = getTypesFromSOQLQuery(node);</span>

<span class="fc" id="L513">        final HashSet&lt;ASTMethodCallExpression&gt; prevCalls = getPreviousMethodCalls(node);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (ASTMethodCallExpression prevCall : prevCalls) {</span>
<span class="fc" id="L515">            collectCRUDMethodLevelChecks(prevCall);</span>
<span class="fc" id="L516">        }</span>

<span class="fc" id="L518">        boolean isGetter = false;</span>
<span class="fc" id="L519">        String returnType = null;</span>

<span class="fc" id="L521">        final ASTMethod wrappingMethod = node.getFirstParentOfType(ASTMethod.class);</span>
<span class="fc" id="L522">        final ASTUserClass wrappingClass = node.getFirstParentOfType(ASTUserClass.class);</span>

<span class="pc bpc" id="L524" title="3 of 8 branches missed.">        if (isCount || (wrappingClass != null &amp;&amp; Helper.isTestMethodOrClass(wrappingClass))</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                || (wrappingMethod != null &amp;&amp; Helper.isTestMethodOrClass(wrappingMethod))) {</span>
<span class="fc" id="L526">            return;</span>
        }

<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if (wrappingMethod != null) {</span>
<span class="fc" id="L530">            isGetter = isMethodAGetter(wrappingMethod);</span>
<span class="fc" id="L531">            returnType = getReturnType(wrappingMethod);</span>
        }

<span class="fc" id="L534">        final ASTVariableDeclaration variableDecl = node.getFirstParentOfType(ASTVariableDeclaration.class);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (variableDecl != null) {</span>
<span class="fc" id="L536">            String type = variableDecl.getNode().getLocalInfo().getType().getApexName();</span>
<span class="fc" id="L537">            type = getSimpleType(type);</span>
<span class="fc" id="L538">            StringBuilder typeCheck = new StringBuilder().append(variableDecl.getNode().getDefiningType().getApexName())</span>
<span class="fc" id="L539">                    .append(&quot;:&quot;).append(type);</span>

<span class="fc bfc" id="L541" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                if (typesFromSOQL.isEmpty()) {</span>
<span class="nc" id="L543">                    validateCRUDCheckPresent(node, data, ANY, typeCheck.toString());</span>
                } else {
<span class="fc bfc" id="L545" title="All 2 branches covered.">                    for (String typeFromSOQL : typesFromSOQL) {</span>
<span class="fc" id="L546">                        validateCRUDCheckPresent(node, data, ANY, typeFromSOQL);</span>
<span class="fc" id="L547">                    }</span>
                }
            }

        }

<span class="fc" id="L553">        final ASTAssignmentExpression assignment = node.getFirstParentOfType(ASTAssignmentExpression.class);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (assignment != null) {</span>
<span class="fc" id="L555">            final ASTVariableExpression variable = assignment.getFirstChildOfType(ASTVariableExpression.class);</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">            if (variable != null) {</span>
<span class="fc" id="L557">                String variableWithClass = Helper.getFQVariableName(variable);</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">                if (varToTypeMapping.containsKey(variableWithClass)) {</span>
<span class="fc" id="L559">                    String type = varToTypeMapping.get(variableWithClass);</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                    if (!isGetter) {</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">                        if (typesFromSOQL.isEmpty()) {</span>
<span class="nc" id="L562">                            validateCRUDCheckPresent(node, data, ANY, type);</span>
                        } else {
<span class="fc bfc" id="L564" title="All 2 branches covered.">                            for (String typeFromSOQL : typesFromSOQL) {</span>
<span class="fc" id="L565">                                validateCRUDCheckPresent(node, data, ANY, typeFromSOQL);</span>
<span class="fc" id="L566">                            }</span>
                        }

                    }
                }
            }

        }

<span class="fc" id="L575">        final ASTReturnStatement returnStatement = node.getFirstParentOfType(ASTReturnStatement.class);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (returnStatement != null) {</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (!isGetter) {</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">                if (typesFromSOQL.isEmpty()) {</span>
<span class="nc" id="L579">                    validateCRUDCheckPresent(node, data, ANY, returnType);</span>
                } else {
<span class="fc bfc" id="L581" title="All 2 branches covered.">                    for (String typeFromSOQL : typesFromSOQL) {</span>
<span class="fc" id="L582">                        validateCRUDCheckPresent(node, data, ANY, typeFromSOQL);</span>
<span class="fc" id="L583">                    }</span>
                }
            }
        }
<span class="fc" id="L587">    }</span>

    private Set&lt;String&gt; getTypesFromSOQLQuery(final ASTSoqlExpression node) {
<span class="fc" id="L590">        final Set&lt;String&gt; retVal = new HashSet&lt;&gt;();</span>
<span class="fc" id="L591">        final String canonQuery = node.getNode().getCanonicalQuery();</span>

<span class="fc" id="L593">        Matcher m = SELECT_FROM_PATTERN.matcher(canonQuery);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L595">            retVal.add(new StringBuffer().append(node.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L596">                    .append(m.group(1)).toString());</span>
        }
<span class="fc" id="L598">        return retVal;</span>
    }

    private String getReturnType(final ASTMethod method) {
<span class="fc" id="L602">        return new StringBuilder().append(method.getNode().getDefiningType().getApexName()).append(&quot;:&quot;)</span>
<span class="fc" id="L603">                .append(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).toString();</span>
    }

    private boolean isMethodAGetter(final ASTMethod method) {
<span class="fc" id="L607">        final boolean startsWithGet = method.getNode().getMethodInfo().getCanonicalName().startsWith(&quot;get&quot;);</span>
<span class="fc" id="L608">        final boolean voidOrString = VOID_OR_STRING_PATTERN</span>
<span class="fc" id="L609">                .matcher(method.getNode().getMethodInfo().getEmitSignature().getReturnType().getApexName()).matches();</span>
<span class="fc" id="L610">        final boolean noParams = method.findChildrenOfType(ASTParameter.class).isEmpty();</span>

<span class="fc bfc" id="L612" title="All 6 branches covered.">        return (startsWithGet &amp;&amp; noParams &amp;&amp; !voidOrString);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>